{"sheets":[{"id":1,"position":1,"sheet":"LeetCode - Top Interview 150","username":"aniket"},{"id":2,"position":2,"sheet":"GFG - SDE SHEET","username":"aniket"},{"id":10,"position":3,"sheet":"Algorithms","username":"aniket"},{"id":12,"position":4,"sheet":"Interview","username":"aniket"}],"topics":[{"id":1,"position":1,"topic":"Array | String","sheetId":1},{"id":5,"position":2,"topic":"Two Pointers","sheetId":1},{"id":6,"position":3,"topic":"Sliding Window","sheetId":1},{"id":7,"position":4,"topic":"Matrix","sheetId":1},{"id":11,"position":15,"topic":"Backtracking","sheetId":1},{"id":12,"position":22,"topic":"1D DP","sheetId":1},{"id":13,"position":23,"topic":"Multidimensional DP","sheetId":1},{"id":24,"position":9,"topic":"Binary Tree General","sheetId":1},{"id":25,"position":10,"topic":"Binary Tree BFS","sheetId":1},{"id":26,"position":11,"topic":"Binary Search Tree","sheetId":1},{"id":27,"position":12,"topic":"Graph General","sheetId":1},{"id":28,"position":13,"topic":"Graph BFS","sheetId":1},{"id":29,"position":5,"topic":"Hashmap","sheetId":1},{"id":30,"position":8,"topic":"Linked List","sheetId":1},{"id":47,"position":6,"topic":"Intervals","sheetId":1},{"id":48,"position":7,"topic":"Stack","sheetId":1},{"id":49,"position":14,"topic":"Trie","sheetId":1},{"id":50,"position":16,"topic":"Divide & Conquer","sheetId":1},{"id":51,"position":17,"topic":"Kadane's Algorithm","sheetId":1},{"id":52,"position":18,"topic":"Binary Search","sheetId":1},{"id":53,"position":20,"topic":"Bit Manipulation","sheetId":1},{"id":54,"position":21,"topic":"Math","sheetId":1},{"id":55,"position":19,"topic":"Heap","sheetId":1},{"id":2,"position":1,"topic":"Arrays","sheetId":2},{"id":3,"position":2,"topic":"Searching and Sorting","sheetId":2},{"id":56,"position":1,"topic":"Tree","sheetId":10},{"id":57,"position":2,"topic":"Graph","sheetId":10},{"id":59,"position":1,"topic":"Fivetran","sheetId":12}],"problems":[{"id":28,"position":1,"title":"Merge Sorted Array","difficulty":1,"link":"https://leetcode.com/problems/merge-sorted-array/","hint":"Start filling array from reverse","notes":"Revision Dates: 06/11/23\nLast Revision Notes: Solved.","solution":"public void merge(int[] nums1, int m, int[] nums2, int n) {\n    int i = m - 1, j = n - 1, k = nums1.length - 1;\n\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j]) nums1[k--] = nums1[i--];\n        else nums1[k--] = nums2[j--];\n    }\n\n    while (i >= 0) nums1[k--] = nums1[i--];\n    while (j >= 0) nums1[k--] = nums2[j--];\n}","topicId":1},{"id":29,"position":2,"title":"Remove Element","difficulty":1,"link":"https://leetcode.com/problems/remove-element/","hint":"we don't need to swap because we don't care about right part of array.","notes":"Revision Dates: 07/11/23\nLast Revision Notes: Solved.","solution":"public int removeElement(int[] nums, int val) {\n    int left = 0, right = nums.length - 1, k = 0;\n    \n    while (left <= right) {\n        if (nums[left] == val) {\n            nums[left] = nums[right--];\n        } else {\n            left++;\n            k++;\n        }\n    }\n    \n    return k;\n}","topicId":1},{"id":30,"position":3,"title":"Remove Duplicates from Sorted Array","difficulty":1,"link":"https://leetcode.com/problems/remove-duplicates-from-sorted-array/","hint":"think of k as left pointer","notes":"Revision Dates: 07/11/23\nLast Revision Notes: Solved.","solution":"public int removeDuplicates(int[] nums) {\n    int k = 0;\n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] != nums[k]) nums[++k] = nums[i];\n    }\n    return k + 1;\n}","topicId":1},{"id":31,"position":4,"title":"Remove Duplicates from Sorted Array II","difficulty":2,"link":"https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/","hint":"Use boolean 'twice' to represent if element occurred 2nd time.","notes":"Revision Dates: 07/11/23\nLast Revision Notes: Solved.","solution":"public int removeDuplicates(int[] nums) {\n    int k = 0;\n    boolean twice = false;\n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] != nums[k]) {\n            nums[++k] = nums[i];\n            twice = false;\n        } else if (!twice) {\n            nums[++k] = nums[i];\n            twice = true;\n        }\n    }\n    return k + 1;\n}","topicId":1},{"id":32,"position":5,"title":"Majority Element","difficulty":1,"link":"https://leetcode.com/problems/majority-element/","hint":"Approach for time: O(n), space: O(1) =>\n* modify the majority only if the current element count > count.","notes":"Revision Dates: 07/11/23\nLast Revision Notes: Solved.","solution":"public int majorityElement(int[] nums) {\n    int count = 1, majority = nums[0];\n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] == majority) count++;\n        else count--;\n\n        if (count < 0) {\n            count = 1;\n            majority = nums[i];\n        }\n    }\n    return majority;\n}","topicId":1},{"id":33,"position":6,"title":"Rotate Array","difficulty":2,"link":"https://leetcode.com/problems/rotate-array/","hint":"Try to rotate the array for n = 4 and k = 2.\nYou will get the intuition for Box Swap technique.\n\n*** I have noticed that '<' or '>' is faster than '='.","notes":"Revision Dates: 07/11/23\nLast Revision Notes: Solved.","solution":"public void rotate(int[] nums, int k) {\n    int n = nums.length, times = k % n;\n    if (times < 0) return;\n    reverse(nums, 0, n - 1);\n    reverse(nums, 0, times - 1);\n    reverse(nums, times, n - 1);\n}\n\nvoid reverse(int[] arr, int left, int right) {\n    while (left < right) {\n        int temp = arr[left];\n        arr[left++] = arr[right];\n        arr[right--] = temp;\n    }\n}","topicId":1},{"id":34,"position":7,"title":"Best Time to Buy and Sell Stock","difficulty":1,"link":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/","hint":"NA","notes":"Revision Dates: 07/11/23\nLast Revision Notes: Solved.","solution":"public int maxProfit(int[] prices) {\n    int profit = 0, buy = prices[0];\n    for (int i = 1; i < prices.length; i++) {\n        if (prices[i] < buy) buy = prices[i];\n        profit = Math.max(prices[i] - buy, profit);\n    }\n    return profit;\n}","topicId":1},{"id":35,"position":8,"title":"Best Time to Buy and Sell Stock II","difficulty":2,"link":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/","hint":"Selling stocks daily is equivalent to selling at the maxPrice day.","notes":"Revision Dates: 07/11/23\nLast Revision Notes: Solved.","solution":"public int maxProfit(int[] prices) {\n    int profit = 0;\n    for (int i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            profit += prices[i] - prices[i - 1];\n        }\n    }\n    return profit;\n}","topicId":1},{"id":36,"position":9,"title":"Jump Game","difficulty":2,"link":"https://leetcode.com/problems/jump-game/","hint":"You can check from both side, but checking from last point is faster:\n* set currentPosition = n - 1;\n* loop from (n - 2 to 0).\n* if(nums[i] + i >= currentPosition) then currentPosition = i.\n* means we can reach from i to currentPosition, so we can update the currentPosition.\n* return currentPosition == 0","notes":"Revision Dates: 07/11/23\nLast Revision Notes: Solved.","solution":"public boolean canJump(int[] nums) {\n    int n = nums.length, currentPosition = n - 1;\n    for (int i = n - 2; i >= 0; i--) {\n        if (i + nums[i] >= currentPosition) {\n            currentPosition = i;\n        }\n    }\n    return currentPosition == 0;\n}","topicId":1},{"id":37,"position":10,"title":"Jump Game II","difficulty":2,"link":"https://leetcode.com/problems/jump-game-ii/","hint":"NA","notes":"Revision Dates: 07/11/23\nLast Revision Notes: Solved.","solution":"public int jump(int[] nums) {\n    int n = nums.length,\n            jump = 0,\n            reachable = 0,\n            reachableAfterJump = 0;\n\n    for (int idx = 0; idx < n; idx++) {\n        if (idx > reachable) {\n            jump++;\n            reachable = reachableAfterJump;\n        }\n        reachableAfterJump = Integer.max(reachableAfterJump, nums[idx] + idx);\n    }\n    \n    return jump;\n}","topicId":1},{"id":38,"position":11,"title":"H-Index","difficulty":2,"link":"https://leetcode.com/problems/h-index/","hint":"Rephrasing the question: Find a number 'num' from an array such that the frequency of (any number >= 'num') is highest.\nh-Index is highest nums calculated by : min(frequency, num)\n\nh-index cannot be greater than n that why we don't need to count frequency for every numbers. if arr[i] >= n we can increase the frequency of n. ","notes":"Revision Dates: 09/11/23\nLast Revision Notes: Solved for O(1000 + N), took help for O(2N) solution.","solution":"public int hIndex(int[] citations) {\n    int n = citations.length;\n    int[] citationFrequency = new int[n + 1];\n    for (int i = 0; i < n; i++) {\n        if (citations[i] >= n) citationFrequency[n]++;\n        else citationFrequency[citations[i]]++;\n    }\n\n    int citationsTillNow = 0;\n    for (int citation = n; citation >= 0; citation--) {\n        citationsTillNow += citationFrequency[citation];\n\n        if (citationsTillNow >= citation) return citation;\n    }\n\n    return 0;\n}","topicId":1},{"id":39,"position":12,"title":"Insert Delete GetRandom O(1)","difficulty":2,"link":"https://leetcode.com/problems/insert-delete-getrandom-o1/","hint":"* Create HashMap for (value, index) and array picking random idx data.\n* Insertion is plain and simple, if element is not exist insert the element to the last.\n* For remove : find the index to be removed form map and put the last index's data to removed index.\n","notes":"Revision Dates: 10/11/23\nLast Revision Notes: Solved with linked list, referred solution for array.","solution":"class RandomizedSet {\n    int[] data;\n    int size;\n    Random random;\n    HashMap<Integer, Integer> valueIndexMap;\n\n    public RandomizedSet() {\n        data = new int[200001];\n        size = 0;\n        random = new Random();\n        valueIndexMap = new HashMap<>();\n    }\n\n    public boolean insert(int val) {\n        if (valueIndexMap.containsKey(val)) return false;\n\n        valueIndexMap.put(val, size);\n        data[size] = val;\n        size++;\n        return true;\n    }\n\n    public boolean remove(int val) {\n        if (!valueIndexMap.containsKey(val)) return false;\n\n        int removedIndex = valueIndexMap.remove(val);\n        if (removedIndex != size - 1) {\n            valueIndexMap.put(data[size - 1], removedIndex);\n            data[removedIndex] = data[size - 1];\n        }\n        size--;\n        return true;\n    }\n\n    public int getRandom() {\n        return data[(random.nextInt() & Integer.MAX_VALUE) % size];\n    }\n}","topicId":1},{"id":40,"position":13,"title":"Product of Array Except Self","difficulty":2,"link":"https://leetcode.com/problems/product-of-array-except-self/","hint":"* Main logic (output [i] = leftProductTill [ i - 1 ] * rightProductTill [ i + 1 ]\nFor O(1) space complexity:\n* Calculate right product in output array. (to avoid if (i + 1 < n) check optimize the index while storing)\n* for leftProduct use one variable.","notes":"Revision Dates: 10/11/23\nLast Revision Notes: Solved","solution":"public int[] productExceptSelf(int[] nums) {\n    int n = nums.length;\n    int[] output = new int[n];\n\n    output[n - 1] = 1;\n    for (int i = n - 2; i >= 0; i--) {\n        output[i] = output[i + 1] * nums[i + 1];\n    }\n\n    int lastProduct = 1;\n    for (int i = 0; i < n; i++) {\n        output[i] = output[i] * lastProduct;\n        lastProduct *= nums[i];\n    }\n\n    return output;\n}","topicId":1},{"id":41,"position":14,"title":"Gas Station","difficulty":2,"link":"https://leetcode.com/problems/gas-station/","hint":"* Keep track of finalTank and tank.\n* if tank < 0 then car cannot goto next stop.\n* re-assign the start variable to i + 1 if at any point of time car cannot go further.","notes":"Revision Dates: 10/11/23\nLast Revision Notes: Solved","solution":"public int canCompleteCircuit(int[] gas, int[] cost) {\n    int n = gas.length,\n            finalTank = 0,\n            tank = 0,\n            start = 0;\n\n    for (int i = 0; i < n; i++) {\n        tank += gas[i] - cost[i];\n        if (tank < 0) {\n            finalTank += tank;\n            tank = 0;\n            start = i + 1;\n        }\n    }\n\n    return tank + finalTank >= 0 ? start : -1;\n}","topicId":1},{"id":42,"position":15,"title":"Candy","difficulty":3,"link":"https://leetcode.com/problems/candy/","hint":"Main logic: If slope is increasing or decreasing we will increase the respective slope and add it to the candy and at every slope cycle (1 increasing + 1 decreasing) we need to remove the minimum slope because 2 slopes are added.\n\nT:O(N) S:O(N) solution.\n* create candy[] and fill with 1 as minimum candy can be 1.\n* First pass ( 1 to n - 1 ) (left to right)\n-- If current rating is greater than left element then candy[i] = candy[i - 1] + 1;\n* Second Pass ( n - 2 to 0 ) (right to left)\n-- if current rating is greater than right element and candy[i] <= candy[i + 1] then\n-- candy[i] = candy[i + 1] + 1. (similar operation can be achieved by max())\n* Sum the candy array and return.\n\nT:O(N)  S:O(1) :\n* assign n candies first (minimum candy).\n* if previous and current raitings are equal continue the loop (candies are already assigned in previous step).\n* if previous rating is smaller then its in increasing order, incresase the up and add it to the candy.\n* else increase the down and add it to the candy.\n* at last keep only the max pease by removing the min(up, down) from candy.\n","notes":"Revision Dates: 12/11/2023\nLast Revision Notes: Watched solution for 0(N) complexity.","solution":"public int candy(int[] ratings) {\n    int n = ratings.length, i = 1, candy = n; //minimum candy\n\n    while (i < n) {\n        if (ratings[i - 1] == ratings[i]) {\n            i++;\n        } else {\n            int up = 0;\n            while (ratings[i - 1] < ratings[i]) {\n                candy += ++up;\n                i++;\n                if (i == n) return candy; //only 1 cycle completed\n            }\n\n            int down = 0;\n            while (i < n && ratings[i - 1] > ratings[i]) {\n                candy += ++down;\n                i++;\n            }\n            //both cycle completed\n            candy -= Integer.min(up, down); //keeping only peak value\n        }\n    }\n\n    return candy;\n}","topicId":1},{"id":43,"position":16,"title":"Trapping Rain Water","difficulty":3,"link":"https://leetcode.com/problems/trapping-rain-water/","hint":"T:O(N) S:O(1):\n* Keep track of leftMaxHeight and rightMaxHeight.\n* if leftMaxHeight: update the rightMaxHeight and caluclate the current water.\n* else update the leftMaxHeight and caluclate the current water.\n* water is caluclated by min(rightMaxHeight, leftMaxHeight) - current height.","notes":"Revision Dates: 13/11/2023\nLast Revision Notes: Solved","solution":"public int trap(int[] height) {\n    int i = 0, j = height.length - 1,\n            leftMaxHeight = 0, rightMaxHeight = 0,\n            water = 0;\n    \n    while (i <= j) {\n        if (leftMaxHeight > rightMaxHeight) {\n            rightMaxHeight = Math.max(rightMaxHeight, height[j]);\n            water += rightMaxHeight - height[j--];\n        } else {\n            leftMaxHeight = Math.max(leftMaxHeight, height[i]);\n            water += leftMaxHeight - height[i++];\n        }\n    }\n\n    return water;\n}","topicId":1},{"id":44,"position":17,"title":"Roman to Integer","difficulty":1,"link":"https://leetcode.com/problems/roman-to-integer/","hint":"* Reverse iterate the string\n* keep track of last value.\n* if last value is greater than the current value then substract\n* else add\n","notes":"Revision Dates: 13/11/2023\nLast Revision Notes: Solved","solution":"public int romanToInt(String s) {\n    short[] values = new short[89]; // 'X' = 88\n    values['I'] = 1;\n    values['V'] = 5;\n    values['X'] = 10;\n    values['L'] = 50;\n    values['C'] = 100;\n    values['D'] = 500;\n    values['M'] = 1000;\n\n    int n = s.length(), integer, last;\n    integer = last = values[s.charAt(n - 1)];\n\n    for (int i = n - 2; i >= 0; i--) {\n        int value = values[s.charAt(i)];\n\n        if (value < last) integer -= value;\n        else integer += value;\n\n        last = value;\n    }\n    \n    return integer;\n}","topicId":1},{"id":45,"position":18,"title":"Integer to Roman","difficulty":2,"link":"https://leetcode.com/problems/integer-to-roman/","hint":"Try to write formula for 1 to 9. \nThe generated fromula is applicable everywhere.","notes":"Revision Dates: 13/11/2023\nLast Revision Notes: Solved","solution":"public String intToRoman(int num) {\n        char[][] symbols = new char[4][3];\n        symbols[0][0] = 'I';\n        symbols[0][1] = 'V';\n        symbols[1][0] = 'X';\n        symbols[1][1] = 'L';\n        symbols[2][0] = 'C';\n        symbols[2][1] = 'D';\n        symbols[3][0] = 'M';\n\n        StringBuffer roman = new StringBuffer();\n        int i = 0, digit;\n        while (num > 0) {\n            digit = num % 10;\n            num /= 10;\n            switch (digit) {\n                case 0:\n                    break;\n                case 1:\n                    roman.append(symbols[i][0]);\n                    break;\n                case 2:\n                    roman.append(symbols[i][0]);\n                    roman.append(symbols[i][0]);\n                    break;\n                case 3:\n                    roman.append(symbols[i][0]);\n                    roman.append(symbols[i][0]);\n                    roman.append(symbols[i][0]);\n                    break;\n                case 4:\n                    roman.append(symbols[i][1]);\n                    roman.append(symbols[i][0]);\n                    break;\n                case 5:\n                    roman.append(symbols[i][1]);\n                    break;\n                case 6:\n                    roman.append(symbols[i][0]);\n                    roman.append(symbols[i][1]);\n                    break;\n                case 7:\n                    roman.append(symbols[i][0]);\n                    roman.append(symbols[i][0]);\n                    roman.append(symbols[i][1]);\n                    break;\n                case 8:\n                    roman.append(symbols[i][0]);\n                    roman.append(symbols[i][0]);\n                    roman.append(symbols[i][0]);\n                    roman.append(symbols[i][1]);\n                    break;\n                case 9:\n                    roman.append(symbols[i + 1][0]);\n                    roman.append(symbols[i][0]);\n                    break;\n            }\n            i++;\n        }\n\n        return roman.reverse().toString();\n    }","topicId":1},{"id":46,"position":19,"title":"Length of Last Word","difficulty":1,"link":"https://leetcode.com/problems/length-of-last-word/","hint":"NA","notes":"Revision Dates: 14/11/2023\nLast Revision Notes: Solved","solution":"public int lengthOfLastWord(String s) {\n    int i = s.length() - 1, count = 0;\n    while (s.charAt(i) == ' ') i--;\n    while (i >= 0 && s.charAt(i--) != ' ') count++;\n    return count;\n}","topicId":1},{"id":47,"position":20,"title":"Longest Common Prefix","difficulty":1,"link":"https://leetcode.com/problems/longest-common-prefix/","hint":"NA","notes":"Revision Dates: 14/11/2023\nLast Revision Notes: StringBuilder is faster than StringBuffer","solution":"public String longestCommonPrefix(String[] strs) {\n    int i = 0, n = strs.length, minLength = Integer.MAX_VALUE;\n\n    for (String str : strs) {\n        minLength = Math.min(minLength, str.length());\n    }\n\n    while (i < minLength) {\n        char ith = strs[0].charAt(i);\n        for (int j = 1; j < n; j++) {\n            if (ith != strs[j].charAt(i)) {\n                return strs[0].substring(0, i);\n            }\n        }\n        i++;\n    }\n\n    return strs[0].substring(0, i);\n}","topicId":1},{"id":48,"position":21,"title":"Reverse Words in a String","difficulty":2,"link":"https://leetcode.com/problems/reverse-words-in-a-string/","hint":"To solve in S:O(1)\n* Reverse the input\n* Reverse every word\n* Remove extra spaces\n","notes":"Revision Dates: 15/11/2023\nLast Revision Notes: S:O(1) not solved.","solution":"void reverse(char[] input, int i, int j) {\n    while (i < j) {\n        char temp = input[i];\n        input[i++] = input[j];\n        input[j--] = temp;\n    }\n}\n\npublic String reverseWords(String s) {\n    char[] input = s.toCharArray();\n    int n = input.length, i = 0, j = 0;\n    //reverse the input\n    reverse(input, 0, n - 1);\n    //reverse each word\n    while (i < n) {\n        while (i < n && input[i] == ' ') i++;\n        j = i;\n        while (j < n && input[j] != ' ') j++;\n        reverse(input, i, j - 1);\n        i = j;\n    }\n    //removing extra space\n    i = j = 0;\n    while (j < n) {\n        while (j < n && input[j] == ' ') j++;\n        while (j < n && input[j] != ' ') input[i++] = input[j++];\n        while (j < n && input[j] == ' ') j++;\n        if (j < n) input[i++] = ' ';\n    }\n\n    return new String(input, 0, i);\n}","topicId":1},{"id":64,"position":22,"title":"Zigzag Conversion","difficulty":2,"link":"https://leetcode.com/problems/zigzag-conversion/\nhttps://www.youtube.com/watch?v=Q2Tw6gcVEwc","hint":"* Calculate steps = 2 * (numRows -1). \n* At every row subSteps are decreased by two. (subStep = step - 2 * row)\n* For first and last row fill only letter at steps.\n* One extra letter at ever step will be added for the middle row.","notes":"Revision Dates: 20/11/2023\nLast Revision Notes: Not able to write logic for ziz-zag formula","solution":"public String convert(String s, int numRows) {\n    int n = s.length();\n    if (numRows == 1 || numRows >= n) return s;\n\n    char[] output = new char[n];\n    int step = 2 * (numRows - 1), subStep = step, index, i = 0;\n\n    for (int row = 0; row < numRows; row++) {\n        index = row;\n\n        while (index < n) {\n            //First character of step\n            output[i++] = s.charAt(index);\n\n            // If row is not the first or last\n            // then we have to add one more character.\n            if (row != 0 && row != numRows - 1 && index + subStep < n) {\n                output[i++] = s.charAt(index + subStep);\n            }\n            // Jump to same row's next step.\n            index += step;\n        }\n\n        subStep -= 2; // subStep is decreased by two at every step.\n    }\n    return new String(output);\n}","topicId":1},{"id":65,"position":23,"title":"Find the Index of the First Occurrence in a String","difficulty":1,"link":"https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/\nhttps://www.youtube.com/watch?v=JoF0Z7nVSrA","hint":"NA","notes":"Revision Dates: 20/11/2023\nLast Revision Notes: Learn the KMP solution","solution":"public int strStr(String haystack, String needle) {\n    char[] key = needle.toCharArray();\n    char[] str = haystack.toCharArray();\n\n    int m = key.length, n = str.length;\n\n    for (int i = 0; i < n; i++) {\n        if (i + m <= n) {\n            int j = i, k = i + m - 1, x = 0, y = m - 1;\n            boolean same = true;\n            while (j <= k) {\n                if (str[j++] != key[x++] || str[k--] != key[y--]) {\n                    same = false;\n                    break;\n                }\n            }\n            if (same) return i;\n        }\n    }\n    return -1;\n}","topicId":1},{"id":66,"position":24,"title":"Text Justification","difficulty":3,"link":"https://leetcode.com/problems/text-justification/","hint":"NA","notes":"Revision Dates: 20/11/2023\nLast Revision Notes: Solved","solution":"public List<String> fullJustify(String[] words, int maxWidth) {\n    int n = words.length;\n    List<String> justified = new ArrayList<>();\n    int currentLength = 0, currentWords = 0, start = 0;\n    for (int i = 0; i < n; i++) {\n        int wordLength = words[i].length();\n        if (currentLength + wordLength + currentWords <= maxWidth) {\n            currentWords++;\n            currentLength += wordLength;\n        } else {\n            justified.add(justify(words, maxWidth, currentLength, currentWords, start));\n            currentLength = wordLength;\n            currentWords = 1;\n            start = i;\n        }\n    }\n\n    justified.add(leftJustify(words, maxWidth, currentWords, start));\n    \n    return justified;\n}\n\nprivate String justify(String[] words, int maxWidth, int wordsLength,\n                                                     int wordsCount, int start) {\n    if (wordsCount == 1) return leftJustify(words, maxWidth, wordsCount, start);\n    else {\n        int totalSpaces = maxWidth - wordsLength;\n        int equalSpaces = totalSpaces / (wordsCount - 1);\n        int extraSpaces = totalSpaces % (wordsCount - 1);\n\n        StringBuilder spaces = new StringBuilder();\n        for (int i = 0; i < equalSpaces; i++) spaces.append(\" \");\n\n        StringBuilder justified = new StringBuilder();\n        for (int i = start; i < start + wordsCount; i++) {\n            if (i != start) {\n                justified.append(spaces);\n                if (extraSpaces > 0) {\n                    justified.append(\" \");\n                    extraSpaces--;\n                }\n            }\n            justified.append(words[i]);\n        }\n        return justified.toString();\n    }\n}\n\n\nprivate String leftJustify(String[] words, int maxWidth, int wordsCount, int start) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = start; i < start + wordsCount; i++) {\n        if (i != start) sb.append(\" \");\n        sb.append(words[i]);\n    }\n\n    int spaces = maxWidth - sb.length();\n    for (int i = 0; i < spaces; i++) {\n        sb.append(\" \");\n    }\n    return sb.toString();\n}","topicId":1},{"id":67,"position":1,"title":"Valid Palindrome","difficulty":1,"link":"https://leetcode.com/problems/valid-palindrome/","hint":"NA","notes":"Revision Dates: 20/11/2023\nLast Revision Notes: Solved","solution":"boolean isDigit(char c) {\n    return c >= '0' & c <= '9';\n}\n\nboolean isAlphabet(char c) {\n    return c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z';\n}\n\nchar toLowerCase(char c) {\n    if (c >= 'A' && c <= 'Z') return (char) (c + 32);\n    else return c;\n}\n\npublic boolean isPalindrome(String s) {\n    int i = 0, j = s.length() - 1;\n    while (i < j) {\n        char a = s.charAt(i), b = s.charAt(j);\n        if (!isDigit(a) && !isAlphabet(a)) i++;\n        else if (!isDigit(b) && !isAlphabet(b)) j--;\n        else {\n            if (isDigit(a) && a != b) return false;\n            else if (toLowerCase(a) != toLowerCase(b)) return false;\n            i++;\n            j--;\n        }\n    }\n    return true;\n}","topicId":5},{"id":68,"position":2,"title":"Is Subsequence","difficulty":1,"link":"https://leetcode.com/problems/is-subsequence/","hint":"NA","notes":"Revision Dates: 20/11/2023\nLast Revision Notes: Solved","solution":"public boolean isSubsequence(String s, String t) {\n    int i1 = 0, j1 = s.length() - 1,\n            i2 = 0, j2 = t.length() - 1;\n\n    while (i1 <= j1 && i2 <= j2) {\n        if (s.charAt(i1) == t.charAt(i2)) {\n            i1++;\n            i2++;\n        } else if (s.charAt(j1) == t.charAt(j2)) {\n            j1--;\n            j2--;\n        } else {\n            i2++;\n            j2--;\n        }\n    }\n\n    return i1 > j1;\n}","topicId":5},{"id":69,"position":3,"title":"Two Sum II - Input Array Is Sorted","difficulty":2,"link":"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/","hint":"NA","notes":"Revision Dates: 20/11/2023\nLast Revision Notes: Solved","solution":"public int[] twoSum(int[] numbers, int target) {\n    int i = 0, j = numbers.length - 1;\n\n    while (i < j) {\n        int sum = numbers[i] + numbers[j];\n\n        if (sum == target) return new int[]{i + 1, j + 1};\n        else if (sum > target) j--;\n        else i++;\n    }\n\n    return new int[]{-1, -1};\n}","topicId":5},{"id":70,"position":4,"title":"Container With Most Water","difficulty":2,"link":"https://leetcode.com/problems/container-with-most-water/","hint":"NA","notes":"Revision Dates: 20/11/2023\nLast Revision Notes: Increasing pointer with while loop is faster.","solution":"public int maxArea(int[] height) {\n    int i = 0, j = height.length - 1, area = 0, minHeight;\n    while (i < j) {\n        minHeight = Math.min(height[i], height[j]);\n        area = Math.max(area, minHeight * (j - i));\n\n        while (i < j && height[i] <= minHeight) i++;\n        while (i < j && height[j] <= minHeight) j--;\n    }\n    return area;\n}","topicId":5},{"id":71,"position":5,"title":"3Sum","difficulty":2,"link":"https://leetcode.com/problems/3sum/description/","hint":"* Sort the array\n* Loop through the array\n* target = -nums[i]\n* now perform two sum in sorted array\n* ignore duplicate elements.","notes":"Revision Dates: 20/11/2023\nLast Revision Notes: Forgot to ignore the duplicate elements.","solution":"public List<List<Integer>> threeSum(int[] nums) {\n    Arrays.sort(nums);\n    List<List<Integer>> threeSum = new ArrayList<>();\n    int i = 0, n = nums.length, low, high, target, sum;\n\n    while (i < n - 2) {\n        low = i + 1;\n        high = n - 1;\n        target = -nums[i];\n\n        while (low < high) {\n            sum = nums[low] + nums[high];\n            if (sum == target) {\n                threeSum.add(Arrays.asList(nums[i], nums[low++], nums[high--]));\n                //Ignoring duplicate elements\n                while (low < high && nums[low - 1] == nums[low]) low++;\n                while (low < high && nums[high + 1] == nums[high]) high--;\n            } else if (sum < target) {\n                low++;\n            } else {\n                high--;\n            }\n        }\n\n        i++;\n        //Ignoring duplicate elements\n        while (i < n && nums[i - 1] == nums[i]) i++;\n    }\n    return threeSum;\n}","topicId":5},{"id":72,"position":1,"title":"Minimum Size Subarray Sum","difficulty":2,"link":"https://leetcode.com/problems/minimum-size-subarray-sum/","hint":"NA","notes":"Revision Dates: 22/11/2023\nLast Revision Notes: Solved","solution":"public int minSubArrayLen(int target, int[] nums) {\n    int n = nums.length, length = Integer.MAX_VALUE, left = 0, sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += nums[i];\n        while (sum >= target) {\n            length = Math.min(length, i - left + 1);\n            sum -= nums[left++];\n        }\n    }\n    return length == Integer.MAX_VALUE ? 0 : length;\n}","topicId":6},{"id":73,"position":2,"title":"Longest Substring Without Repeating Characters","difficulty":2,"link":"https://leetcode.com/problems/longest-substring-without-repeating-characters/","hint":"New approach\n* create lastIdxAfter[128] array to store (last index of character) + 1. Means next unique character.\n* At every iteration calculate left as max(left,  lastIdxAfter[str[right]). From where unique chars start.\n* then update the length accordingly.","notes":"Revision Dates: 22/11/2023\nLast Revision Notes: Solved","solution":"public int lengthOfLongestSubstring(String s) {\n    char[] str = s.toCharArray();\n    int[] lastIdxAfter = new int[128];\n    int n = str.length, left = 0, length = 0;\n    for (int right = 0; right < n; right++) {\n        left = Math.max(left, lastIdxAfter[str[right]]);\n        length = Math.max(length, right + 1 - left);\n        lastIdxAfter[str[right]] = right + 1;\n    }\n    return length;\n}","topicId":6},{"id":75,"position":3,"title":"Minimum Window Substring","difficulty":3,"link":"https://leetcode.com/problems/minimum-window-substring/\nhttps://www.youtube.com/watch?v=jSto0O4AJbM","hint":"Acquire, Release, Matched technique.\n* Initial requiredMatch will be no of unique characters in String t.\n* decrease the requiredMatch when frequency is equal.\n* keep acquiring till requiredMatch == 0. (all character found in window)\n* keep releasing and calculate start, end of window while requiredMatch == 0. (To get the min window)","notes":"Revision Dates: 27/11/2023\nLast Revision Notes: Not able to write optimized code","solution":"public String minWindow(String s, String t) {\n    int m = s.length(), n = t.length(), requiredMatch = 0;\n    if (s.isEmpty() || t.isEmpty() || n > m) return \"\";\n\n    int[] tFreq = new int[128];\n    for (int i = 0; i < n; i++) {\n        char key = t.charAt(i);\n        if (tFreq[key] == 0) requiredMatch++; //unique characters\n        tFreq[key]++;\n    }\n\n    int[] window = new int[128];\n    int lt = 0, start = 0, end = Integer.MAX_VALUE;\n    for (int rt = 0; rt < m; rt++) {\n        char key = s.charAt(rt);\n        if (tFreq[key] != 0) {\n            window[key]++;\n            if (window[key] == tFreq[key]) requiredMatch--; //same frequency as tFreq\n            while (requiredMatch == 0) {\n                if (end - start > rt - lt) {\n                    start = lt;\n                    end = rt;\n                }\n                key = s.charAt(lt++);\n                if (window[key] != 0) {\n                    window[key]--;\n                    if (window[key] < tFreq[key]) requiredMatch++; //when freq < tFreq\n                }\n            }\n        }\n    }\n\n    return end == Integer.MAX_VALUE ? \"\" : s.substring(start, end + 1);\n}","topicId":6},{"id":76,"position":4,"title":"Substring with Concatenation of All Words","difficulty":3,"link":"https://leetcode.com/problems/substring-with-concatenation-of-all-words/","hint":"Algo:\n* Outer will run wordLen times. (To cover all qualified words)\n* Inner loop will run for every word starting from i.\n* if the current word exist in wordsMap, then increase the frequency.\n* And if(no of words = words.length) check if both maps are equal then add it to answer and remove the last word.\n* Else if current word is not in wordsMap then reset the window and start from next word.","notes":"Revision Dates: 27/11/2023\nLast Revision Notes: Not able to write optimized code","solution":"public List<Integer> findSubstring(String s, String[] words) {\n    int wordLen = words[0].length(), wordsSize = words.length, windowLen = wordLen * wordsSize, n = s.length();\n    List<Integer> ans = new ArrayList<>();\n    if (windowLen > n) return ans;\n    \n    Map<String, Integer> wordsFreq = new HashMap<>();\n    for (String str : words) \n        wordsFreq.put(str, wordsFreq.getOrDefault(str, 0) + 1);\n\n    String[] wordAt = new String[n];\n    for (int i = 0; i < wordLen; i++) {\n        Map<String, Integer> winFreq = new HashMap<>();\n        int windowIdx = i, wordsInWindow = 0;\n        for (int j = i; j <= n - wordLen; j += wordLen) {\n            wordAt[j] = s.substring(j, j + wordLen);\n            if (wordsFreq.containsKey(wordAt[j])) {\n                windowIdx = windowIdx == -1 ? j : windowIdx; // -1 means new window need to be started\n                wordsInWindow++;\n\n                winFreq.put(wordAt[j], winFreq.getOrDefault(wordAt[j], 0) + 1);\n                if (wordsInWindow == wordsSize) {\n                    if (winFreq.equals(wordsFreq)) ans.add(windowIdx); //answer found\n                    winFreq.put(wordAt[windowIdx], winFreq.get(wordAt[windowIdx]) - 1);\n                    windowIdx += wordLen;  // new starting index\n                    wordsInWindow--;\n                }\n            } else { //Reset window\n                windowIdx = -1;\n                wordsInWindow = 0;\n                winFreq.clear();\n            }\n        }\n    }\n    return ans;\n}","topicId":6},{"id":77,"position":1,"title":"Valid Sudoku","difficulty":2,"link":"https://leetcode.com/problems/valid-sudoku/","hint":"NA","notes":"Revision Dates: 28/11/2023\nLast Revision Notes: Solved","solution":"public boolean isValidSudoku(char[][] board) {\n    boolean[][] rows = new boolean[9][9];\n    boolean[][] cols = new boolean[9][9];\n    boolean[][] boxes = new boolean[9][9];\n\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            if (board[i][j] == '.') continue;\n\n            int idx = board[i][j] - 49;\n            int box = (i / 3) * 3 + (j / 3);\n            \n            if (rows[i][idx] || cols[j][idx] || boxes[box][idx]) {\n                return false;\n            }\n\n            rows[i][idx] = cols[j][idx] = boxes[box][idx] = true;\n        }\n    }\n\n    return true;\n}","topicId":7},{"id":78,"position":2,"title":"Spiral Matrix","difficulty":2,"link":"https://leetcode.com/problems/spiral-matrix/","hint":"* Use for vars like rowStart, rowEnd, colStart and colEnd.\n* Write condition for all the four directions\n* And for left and up exta if check is required because rowStart and colEnd is increased/decreased for Right and down.","notes":"Revision Dates: 28/11/2023\nLast Revision Notes: Not solved quickly","solution":"public List<Integer> spiralOrder(int[][] matrix) {\n    List<Integer> spiral = new LinkedList<>();\n\n    int rowStart = 0, rowEnd = matrix.length - 1,\n            colStart = 0, colEnd = matrix[0].length - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        //Right\n        for (int i = colStart; i <= colEnd; i++) spiral.add(matrix[rowStart][i]);\n        rowStart++;\n\n        //Down\n        for (int i = rowStart; i <= rowEnd; i++) spiral.add(matrix[i][colEnd]);\n        colEnd--;\n\n        //Left\n        if (rowStart <= rowEnd) {\n            for (int i = colEnd; i >= colStart; i--) spiral.add(matrix[rowEnd][i]);\n        }\n        rowEnd--;\n\n        //Up\n        if (colStart <= colEnd) {\n            for (int i = rowEnd; i >= rowStart; i--) spiral.add(matrix[i][colStart]);\n        }\n        colStart++;\n    }\n\n    return spiral;\n}","topicId":7},{"id":80,"position":3,"title":"Rotate Image","difficulty":2,"link":"https://leetcode.com/problems/rotate-image/","hint":"* Start from last row and first column\n* Swap row's last element with col's first element till row's second element and col's second last element.\n* decrease row, increase col while row > 0.\n* Reverse every column. \n\nAlgo:\n        //first we take transpose of the matrix\n        for(int i = 0; i < n; ++i){\n            for(int j = i; j < n; ++j){\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n        \n        //then we take mirror image about the middle vertical line\n        for(int i = 0; i < n; ++i){\n            reverse(matrix[i].begin(), matrix[i].end());\n        }","notes":"Revision Dates: 29/11/2023\nLast Revision Notes: Solved","solution":"public void rotate(int[][] matrix) {\n    int n = matrix.length, row = n - 1, col = 0;\n\n    while (row > 0) {\n        for (int i = 0; i < row; i++) {\n            swap(matrix, i, col, row, n - i - 1);\n        }\n        row--;\n        col++;\n    }\n\n    //Reversing columns\n    for (col = 0; col < n; col++) {\n        int low = 0, high = n - 1;\n        while (low < high) {\n            swap(matrix, low++, col, high--, col);\n        }\n    }\n}\n\n\nprivate void swap(int[][] matrix, int i1, int j1, int i2, int j2) {\n    int temp = matrix[i1][j1];\n    matrix[i1][j1] = matrix[i2][j2];\n    matrix[i2][j2] = temp;\n}","topicId":7},{"id":82,"position":4,"title":"Set Matrix Zeroes","difficulty":2,"link":"https://leetcode.com/problems/set-matrix-zeroes/\nhttps://www.youtube.com/watch?v=N0MgLvceX7M","hint":"* Use first row for determining if the corresponding column need to set to zero.\n* Use first column for determining if the corresponding row need to set to zero.\n* We are using [0,0] for both row and column mapping, so we will use new variable col0 for column mapping.\n* Iterate through the array if matrix[i][j] = 0 then mark [i][0] and [0][j] to 0.\n* again iterate and check if corresponding first row or column is marked to 0 then set matrix[i][j] to 0.","notes":"Revision Dates: 30/11/2023\nLast Revision Notes: Not able to solve in S:O(1)","solution":"public void setZeroes(int[][] matrix) {\n    int rows = matrix.length, cols = matrix[0].length, col0 = 1;\n\n    for (int i = 0; i < rows; i++) {\n        if (matrix[i][0] == 0) col0 = 0; // handling for 0th column\n        for (int j = 1; j < cols; j++) {\n            if (matrix[i][j] == 0) {\n                matrix[i][0] = matrix[0][j] = 0;\n            }\n        }\n    }\n\n    for (int i = rows - 1; i >= 0; i--) {\n        for (int j = cols - 1; j > 0; j--) {\n            if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                matrix[i][j] = 0;\n            }\n        }\n        if (col0 == 0) matrix[i][0] = 0; //setting 0th row to 0 if col0 = 0\n    }\n}","topicId":7},{"id":83,"position":5,"title":"Game of Life","difficulty":2,"link":"https://leetcode.com/problems/game-of-life/","hint":"NA","notes":"Revision Dates: 30/11/2023\nLast Revision Notes: Solved","solution":"public void gameOfLife(int[][] board) {\n    int m = board.length, n = board[0].length;\n    int[][] neighbors = new int[][]{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},\n            {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n\n    //replacing 0 / 1 with their neighbour count + 1 in -ve / +ve\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            //starting count with 1 to distinguish between 0 & 1\n            int count = 1;\n            for (int[] neighbor : neighbors) {\n                int i1 = i + neighbor[0], j1 = j + neighbor[1];\n                if (i1 >= 0 && i1 < m && j1 >= 0 && j1 < n && board[i1][j1] > 0) count++;\n            }\n\n            if (board[i][j] == 0) board[i][j] = -count;\n            else board[i][j] = count;\n        }\n    }\n\n    //playing game of life\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (board[i][j] > 0) {\n                int count = board[i][j] - 1;\n                board[i][j] = count == 2 || count == 3 ? 1 : 0;\n            } else {\n                int count = -board[i][j] - 1;\n                board[i][j] = count == 3 ? 1 : 0;\n            }\n        }\n    }\n\n}","topicId":7},{"id":84,"position":1,"title":"Letter Combinations of a Phone Number","difficulty":2,"link":"https://leetcode.com/problems/letter-combinations-of-a-phone-number/","hint":"Perform DFS","notes":"Revision Dates: 30/11/2023\nLast Revision Notes: Solved","solution":"class Solution {\n    String digits;\n    List<String> combinations;\n    char[][] map;\n\n    public List<String> letterCombinations(String digits) {\n        this.digits = digits;\n        combinations = new ArrayList<>();\n\n        if (digits.isEmpty()) return combinations;\n\n        map = new char[][]{{}, {}, {'a', 'b', 'c'}, {'d', 'e', 'f'},\n                {'g', 'h', 'i'}, {'j', 'k', 'l'}, {'m', 'n', 'o'},\n                {'p', 'q', 'r', 's'}, {'t', 'u', 'v'}, {'w', 'x', 'y', 'z'}};\n\n        helper(0, new char[digits.length()]);\n        return combinations;\n    }\n\n    public void helper(int idx, char[] combination) {\n        if (idx == digits.length()) {\n            combinations.add(new String(combination));\n            return;\n        }\n\n        int digit = digits.charAt(idx) - '0';\n        for (char letter : map[digit]) {\n            combination[idx] = letter;\n            helper(idx + 1, combination);\n        }\n    }\n}","topicId":11},{"id":85,"position":2,"title":"Combinations","difficulty":2,"link":"https://leetcode.com/problems/combinations/\nhttps://www.youtube.com/watch?v=q0s6m7AiM7o","hint":"Start with 1 and call only the element which is greater that start.","notes":"Revision Dates: 30/11/2023\nLast Revision Notes: need to watch the solution for optimal.","solution":"class Solution {\n    int n, k;\n    List<List<Integer>> combinations;\n\n    public List<List<Integer>> combine(int n, int k) {\n        this.n = n;\n        this.k = k;\n        combinations = new ArrayList<>();\n        helper(0, 1, new ArrayList<>(k));\n        return combinations;\n    }\n\n    public void helper(int idx, int start, ArrayList<Integer> combination) {\n        if (idx == k) {\n            combinations.add(new ArrayList<>(combination));\n        } else {\n            for (int i = start; i <= n; i++) {\n                combination.add(i);\n                helper(idx + 1, i + 1, combination);\n                combination.remove(combination.size() - 1);\n            }\n        }\n    }\n}","topicId":11},{"id":86,"position":3,"title":"Permutations","difficulty":2,"link":"https://leetcode.com/problems/permutations/","hint":"remove one number form input and append it to output.\neg: [input] : [output] = [1,2,3] : []\n* Level 1 -> [2,3]:[1] , [1,3]:[2] , [1,2]:[3]\n* Level 2 -> [3]:[1,2] , [2]:[1,3] , [3]:[2,1] , [1]:[2,3],  [2]:[3,1] , [1]:[3,2]\n* Level 3 -> []:[3,1,2] , []:[2,1,3] , []:[3,2,1] , []:[1,2,3] , []:[2,3,1] , []:[1,3,2]","notes":"Revision Dates: 30/11/2023\nLast Revision Notes: Solved","solution":"class Solution {\n    List<List<Integer>> permutations;\n\n    public List<List<Integer>> permute(int[] nums) {\n        permutations = new LinkedList<>();\n        LinkedList<Integer> input = new LinkedList<>();\n        for (int num : nums) input.add(num);\n        helper(input, new LinkedList<>());\n        return permutations;\n    }\n\n    void helper(LinkedList<Integer> input, LinkedList<Integer> output) {\n        if (input.isEmpty()) {\n            permutations.add(new LinkedList<>(output));\n        } else {\n            int inputSize = input.size();\n            for (int i = 0; i < inputSize; i++) {\n                LinkedList<Integer> newInput = new LinkedList<>(input);\n                output.addLast(newInput.remove(i));\n                helper(newInput, output);\n                output.removeLast();\n            }\n        }\n    }\n}","topicId":11},{"id":87,"position":4,"title":"Combination Sum","difficulty":2,"link":"https://leetcode.com/problems/combination-sum/","hint":"At each index we have to take two decisions\n1) Skip the current number and move to next element\n2) add the current number and keep the same index.","notes":"Revision Dates: 30/11/2023\nLast Revision Notes: Solved","solution":"class Solution {\n    int target;\n    int[] candidates;\n    List<List<Integer>> combinations;\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        this.candidates = candidates;\n        this.target = target;\n        combinations = new LinkedList<>();\n        helper(0, 0, new LinkedList<>());\n        return combinations;\n    }\n\n    void helper(int idx, int sum, LinkedList<Integer> output) {\n        if (sum == target) {\n            combinations.add(new ArrayList<>(output));\n            return;\n        }\n        \n        if (idx == candidates.length || sum > target) return;\n\n        helper(idx + 1, sum, output); //ignoring the candidate\n        output.addLast(candidates[idx]);\n        helper(idx, sum + candidates[idx], output); //considering the candidate\n        output.removeLast();\n\n    }\n}","topicId":11},{"id":88,"position":5,"title":"N-Queens II","difficulty":3,"link":"https://leetcode.com/problems/n-queens-ii/description/","hint":"Start with row 0 and n queen.\n* for every column check if the position is safe.\n* If safe then mark the board and got to next row.","notes":"Revision Dates: 30/11/2023\nLast Revision Notes: Solved","solution":"class Solution {\n    int solutions;\n    boolean[][] board;\n    int[][] directions;\n\n    void helper(int row, int queens) {\n        if (row == board.length) {\n            solutions = queens == 0 ? solutions + 1 : solutions;\n            return;\n        }\n\n        for (int i = 0; i < board.length; i++) {\n            if (isSafe(row, i)) {\n                board[row][i] = true;\n                helper(row + 1, queens - 1);\n                board[row][i] = false;\n            }\n        }\n    }\n\n    boolean isSafe(int row, int col) {\n        int n = board.length;\n        for (int[] direction : directions) {\n            int i = row + direction[0], j = col + direction[1];\n            while (i >= 0 && i < n && j >= 0 && j < n) {\n                if (board[i][j]) return false;\n                i += direction[0];\n                j += direction[1];\n            }\n        }\n\n        return true;\n    }\n\n    public int totalNQueens(int n) {\n        solutions = 0;\n        board = new boolean[n][n];\n        directions = new int[][]{{-1, -1}, {-1, 0}, {-1, 1},\n                {0, -1}, {0, 1}, {1, -1}, {-1, 0}, {1, 1}};\n\n        helper(0, n);\n        return solutions;\n    }\n}","topicId":11},{"id":89,"position":6,"title":"Generate Parentheses","difficulty":2,"link":"https://leetcode.com/problems/generate-parentheses/","hint":"If count of open and close are equal then paranthesis is valid.","notes":"Revision Dates: 30/11/2023\nLast Revision Notes: Need to check the solution","solution":"class Solution {\n    int n;\n    char[] output;\n    List<String> validCombinations;\n    \n    void helper(int idx, int open, int close) {\n        if (output.length == idx) {\n            validCombinations.add(new String(output));\n            return;\n        }\n\n        if (open < n) {\n            output[idx] = '(';\n            helper(idx + 1, open + 1, close);\n        }\n\n        if (close < open) {\n            output[idx] = ')';\n            helper(idx + 1, open, close + 1);\n        }\n    }\n\n    public List<String> generateParenthesis(int n) {\n        this.n = n;\n        output = new char[n * 2];\n        validCombinations = new LinkedList<>();\n        helper(0, 0, 0);\n        return validCombinations;\n    }\n}","topicId":11},{"id":90,"position":7,"title":"Word Search","difficulty":2,"link":"https://leetcode.com/problems/word-search/","hint":"Use multidimentional dfs.","notes":"Revision Dates: 30/11/2023\nLast Revision Notes: Solved","solution":"class Solution {\n    boolean isExist;\n    int[][] neighbours;\n    boolean[][] visited;\n\n    void helper(int idx, char[][] board, String word, int i, int j) {\n        if (idx == word.length()) isExist = true;\n        else if (!isExist) {\n            int m = board.length, n = board[0].length;\n            for (int[] neighbour : neighbours) {\n                int i1 = i + neighbour[0], j1 = j + neighbour[1];\n                if (i1 >= 0 && j1 >= 0 && i1 < m && j1 < n &&\n                        board[i1][j1] == word.charAt(idx) && !visited[i1][j1]) {\n                    visited[i1][j1] = true;\n                    helper(idx + 1, board, word, i1, j1);\n                    visited[i1][j1] = false;\n                }\n            }\n        }\n    }\n\n    public boolean exist(char[][] board, String word) {\n        isExist = false;\n        neighbours = new int[][]{{-1, 0}, {0, -1}, {0, 1}, {1, 0}};\n        int m = board.length, n = board[0].length;\n        visited = new boolean[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (board[i][j] == word.charAt(0)) {\n                    visited[i][j] = true;\n                    helper(1, board, word, i, j);\n                    visited[i][j] = false;\n                }\n            }\n        }\n        return isExist;\n    }\n}","topicId":11},{"id":91,"position":1,"title":"Climbing Stairs","difficulty":1,"link":"https://leetcode.com/problems/climbing-stairs/","hint":"NA","notes":"Revision Dates: 30/11/2023, 11/01/2024\nLast Revision Notes: Solved","solution":"/*\n//Memoization\npublic int climbStairs(int n) {\n    Integer[] memo = new Integer[n + 1];\n    return dfs(n, memo);\n}\n\nint dfs(int n, Integer[] memo) {\n    if (n <= 3) return n;\n    if (memo[n] != null) return memo[n];\n\n    memo[n] = dfs(n - 1, memo) + dfs(n - 2, memo);\n    return memo[n];\n}\n*/\n\npublic int climbStairs(int n) {\n    int[] dp = new int[n + 1];\n    dp[0] = dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}","topicId":12},{"id":92,"position":2,"title":"House Robber","difficulty":2,"link":"https://leetcode.com/problems/house-robber/","hint":"Recursion Decision:\n1) Take the current element (add nums[i] ) and go to i + 2 element.\n2) Skip current element and and got to next element.\n\nMemo: don't use accumulator.\n\nTabulation:\n* Start from last elelment.\n* check if we can take nums[i] + dp[i + 2] or dp[i + 1]. ","notes":"Revision Dates: 1/12/2023, 11/01/2024\nLast Revision Notes: Solved","solution":"/*\n//Memoization Solution\npublic int rob(int[] nums) {\n    return dfs(nums, nums.length - 1, new Integer[nums.length]);\n}\n\npublic int dfs(int[] nums, int idx, Integer[] memo) {\n    if (idx < 0) return 0;\n    if (memo[idx] != null) return memo[idx];\n\n    int take = nums[idx] + dfs(nums, idx - 2, memo);\n    int skip = dfs(nums, idx - 1, memo);\n\n    memo[idx] = Math.max(take, skip);\n    return memo[idx];\n}\n*/\n\n\npublic int rob(int[] nums) {\n    int n = nums.length;\n    int[] dp = new int[n + 2];\n    for (int i = n - 1; i >= 0; i--) {\n        dp[i] = Math.max(nums[i] + dp[i + 2], dp[i + 1]);\n    }\n    return dp[0];\n}","topicId":12},{"id":93,"position":3,"title":"Word Break","difficulty":2,"link":"https://leetcode.com/problems/word-break/\nhttps://www.youtube.com/watch?v=Sx9NNgInc3A","hint":"Recursion:\nTry every word at each index and if index == s.length() return true.\n\nTabular:\nAssign dp[n] =  true;\n* Reverse iterate the array.\n* check if any word can fit at current index and after that word dp is true.\n* This means we can for word till i, mark the dp[i] = true; ","notes":"Revision Dates: 1/12/2023, 11/01/2024\nLast Revision Notes: Solved","solution":"/*\n// Memoization\npublic boolean wordBreak(String s, List<String> wordDict) {\n    int n = s.length();\n    Boolean[] memo = new Boolean[n];\n    return dfs(s, wordDict, n - 1, memo);\n}\n\nboolean dfs(String s, List<String> wordDict, int idx, Boolean[] memo) {\n    if (idx < 0) return true;\n    if (memo[idx] != null) return memo[idx];\n\n    boolean isPossible = false;\n    for (String word : wordDict) {\n        int m = word.length() - 1;\n        if (idx - m >= 0 && isSubstring(s, word, idx, m) && dfs(s, wordDict, idx - m - 1, memo)) {\n            isPossible = true;\n            break;\n        }\n    }\n\n    memo[idx] = isPossible;\n    return isPossible;\n}\n\nboolean isSubstring(String a, String b, int i, int j) {\n    while (i >= 0 && j >= 0) {\n        if (a.charAt(i--) != b.charAt(j--)) return false;\n    }\n    return true;\n}\n*/\n\npublic boolean wordBreak(String s, List<String> wordDict) {\n    int n = s.length();\n    boolean[] dp = new boolean[n + 1];\n    dp[0] = true;\n    for (int i = 0; i < n; i++) {\n        if (!dp[i]) continue;\n\n        for (String word : wordDict) {\n            int m = word.length();\n            if (i + m <= n && s.startsWith(word, i)) {\n                if (i + m == n) return true;\n                dp[i + m] = true;\n            }\n        }\n    }\n    return false;\n}","topicId":12},{"id":94,"position":4,"title":"Coin Change","difficulty":2,"link":"https://leetcode.com/problems/coin-change/","hint":"Since coins.length <= 12, so outer for loop will be coins.\nInner for loop will be coins to amount.\n","notes":"Revision Dates: 2/12/2023, 11/01/2024\nLast Revision Notes: Need to rethink for outer loop with coin ","solution":"/*\n// Memoization\npublic int coinChange(int[] coins, int amount) {\n    Integer[] memo = new Integer[amount + 1];\n    int minCoin = dfs(coins, amount, memo);\n    return minCoin == Integer.MAX_VALUE ? -1 : minCoin;\n}\n\nint dfs(int[] coins, int amount, Integer[] memo) {\n    if (amount == 0) return 0;\n    if (memo[amount] != null) return memo[amount];\n\n    int minCoin = Integer.MAX_VALUE;\n    for (int coin : coins) {\n        if (amount - coin >= 0) {\n            minCoin = Math.min(minCoin, dfs(coins, amount - coin, memo));\n        }\n    }\n    if (minCoin != Integer.MAX_VALUE) minCoin += 1;\n    \n    memo[amount] = minCoin;\n    return minCoin;\n}\n*/\n\npublic int coinChange(int[] coins, int amount) {\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, amount + 1);\n    dp[0] = 0;\n\n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] = Math.min(dp[i], 1 + dp[i - coin]);\n        }\n    }\n\n    if (dp[amount] == amount + 1) return -1;\n    else return dp[amount];\n}","topicId":12},{"id":95,"position":5,"title":"Longest Increasing Subsequence","difficulty":2,"link":"https://leetcode.com/problems/longest-increasing-subsequence/\nhttps://www.youtube.com/watch?v=on2hvxBXJH4","hint":"The main logic:\n* keep increasing the size i.e. (end) and store at last, if the current element is greater than all dp[] elements.\n* if the element found in dp, do nothing.\n* if element not found in dp, replace it with next greater element in dp.\n\nBy doing this we are ensuring that the size of dp[] is equivalent to Longest Increasing Subsequence because\n* we are only increasing the size of dp when the current element is greater than all the elements in dp.\n* and for the rest case we are just replacing with next greatest element.","notes":"Revision Dates: 2/12/2023, 11/01/2024\nLast Revision Notes: forgot put and use values in dp in ascending order.","solution":"/*\n// Memoization\npublic int lengthOfLIS(int[] nums) {\n    Integer[][] memo = new Integer[nums.length + 1][nums.length + 1];\n    return dfs(nums, 0, 0, memo);\n}\n\nint dfs(int[] nums, int idx, int prevIdx, Integer[][] memo) {\n    if (idx == nums.length) return 0;\n    if (memo[idx][prevIdx] != null) return memo[idx][prevIdx];\n\n    int maxLen = 0;\n    if (prevIdx == 0 || nums[idx] > nums[prevIdx - 1]) {\n        maxLen = 1 + dfs(nums, idx + 1, idx + 1, memo);\n    }\n\n    maxLen = Math.max(maxLen, dfs(nums, idx + 1, prevIdx, memo));\n    memo[idx][prevIdx] = maxLen;\n    return maxLen;\n}\n*/\n\npublic int lengthOfLIS(int[] nums) {\n    int[] dp = new int[nums.length];\n    int size = 0;\n    for (int num : nums) {\n        int i = upperBound(dp, num, 0, size - 1);\n        if (i == -1) dp[size++] = num;\n        else dp[i] = num;\n    }\n    return size;\n}\n\nint upperBound(int[] arr, int target, int low, int high) {\n    if (low > high) return -1;\n    int mid = low + (high - low) / 2;\n\n    if (arr[mid] >= target) {\n        int justBigger = upperBound(arr, target, low, mid - 1);\n        return justBigger == -1 ? mid : justBigger;\n    } else {\n        return upperBound(arr, target, mid + 1, high);\n    }\n}","topicId":12},{"id":96,"position":1,"title":"Triangle","difficulty":2,"link":"https://leetcode.com/problems/triangle/","hint":"If you watch closely you can use the 1D dp array by using previous and current pointer.","notes":"Revision Dates: 2/12/2023, 14/01/2024\nLast Revision Notes: Solved","solution":"/*\n// memoization\npublic int minimumTotal(List<List<Integer>> triangle) {\n    Integer[][] memo = new Integer[triangle.size() + 1][triangle.size() + 1];\n    return dfs(0, 0, triangle, memo);\n}\n\nint dfs(int row, int col, List<List<Integer>> triangle, Integer[][] memo) {\n    if (row == triangle.size()) return 0;\n    if (memo[row][col] != null) return memo[row][col];\n\n    memo[row][col] = triangle.get(row).get(col) +\n            Math.min(dfs(row + 1, col, triangle, memo), dfs(row + 1, col + 1, triangle, memo));\n    return memo[row][col];\n}\n*/\n\npublic int minimumTotal(List<List<Integer>> triangle) {\n    int n = triangle.size();\n    int[] dp = new int[n + 1];\n    for (int row = n - 1; row >= 0; row--) {\n        int prev = dp[row + 1];\n        for (int col = row; col >= 0; col--) {\n            int temp = dp[col];\n            dp[col] = triangle.get(row).get(col) + Math.min(dp[col], prev);\n            prev = temp;\n        }\n    }\n    return dp[0];\n}","topicId":13},{"id":175,"position":2,"title":"Minimum Path Sum","difficulty":2,"link":"https://leetcode.com/problems/minimum-path-sum/","hint":"* Fill the 2d dp array with Integer.MAX_VALUE.\n* set bottom right value of dp.\n* Reverse iterate the dp array and keep updating the up and left neighbours.\n* return dp[0][0].","notes":"Revision Dates: 4/12/2023, 14/01/2024\nLast Revision Notes: Solved","solution":"/*\n// memoization\npublic int minPathSum(int[][] grid) {\n    Integer[][] memo = new Integer[grid.length][grid[0].length];\n    return dfs(0, 0, grid, memo);\n}\n\nint dfs(int row, int col, int[][] grid, Integer[][] memo) {\n    if (row == grid.length - 1 && col == grid[0].length - 1) return grid[row][col];\n    if (memo[row][col] != null) return memo[row][col];\n\n    int min = Integer.MAX_VALUE;\n    if (row + 1 < grid.length)    min = Math.min(min, dfs(row + 1, col, grid, memo));\n    if (col + 1 < grid[0].length) min = Math.min(min, dfs(row, col + 1, grid, memo));\n\n    memo[row][col] = grid[row][col] + min;\n    return memo[row][col];\n}\n*/\n\npublic int minPathSum(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n    int[][] dp = new int[m + 1][n + 1];\n    for (int i = 0; i <= m; i++) dp[i][n] = Integer.MAX_VALUE;\n    for (int j = 0; j <= n; j++) dp[m][j] = Integer.MAX_VALUE;\n\n    dp[m - 1][n] = 0;\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            dp[i][j] = grid[i][j] + Math.min(dp[i + 1][j], dp[i][j + 1]);\n        }\n    }\n    return dp[0][0];\n}","topicId":13},{"id":176,"position":3,"title":"Unique Paths II","difficulty":2,"link":"https://leetcode.com/problems/unique-paths-ii/","hint":"NA","notes":"Revision Dates: 4/12/2023, 15/01/2024\nLast Revision Notes: Solved","solution":"/*\n// Memoization\npublic int uniquePathsWithObstacles(int[][] obstacleGrid) {\n    int m = obstacleGrid.length, n = obstacleGrid[0].length;\n    Integer[][] memo = new Integer[m][n];\n    return dfs(m - 1, n - 1, obstacleGrid, memo);\n}\n\npublic int dfs(int row, int col, int[][] grid, Integer[][] memo) {\n    if (row < 0 || col < 0 || grid[row][col] == 1) return 0;\n    if (row == 0 && col == 0) return 1;\n    if (memo[row][col] != null) return memo[row][col];\n    memo[row][col] = dfs(row - 1, col, grid, memo) + dfs(row, col - 1, grid, memo);\n    return memo[row][col];\n}\n*/\n\npublic int uniquePathsWithObstacles(int[][] obstacleGrid) {\n    int m = obstacleGrid.length, n = obstacleGrid[0].length;\n    int[][] dp = new int[m + 1][n + 1];\n    dp[m - 1][n] = 1;\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i + 1][j] + dp[i][j + 1];\n        }\n    }\n    return dp[0][0];\n}","topicId":13},{"id":177,"position":4,"title":"Longest Palindromic Substring","difficulty":2,"link":"https://leetcode.com/problems/longest-palindromic-substring/\nhttps://www.youtube.com/watch?v=WpYHNHofwjc","hint":"More efficient solution is consider ith element as middle element (low = i-1 & high = i+1) and start expanding outward till low and high elements are equal.\nAlso handle the edge case when consecutive elements are equal then keep increasing till charAt(high) == charA(low) then start expanding as above.","notes":"Revision Dates: 6/12/2023, 15/01/2024\nLast Revision Notes: Not able to write the tabulation","solution":"/*\n// Memoization\npublic String longestPalindrome(String s) {\n    int n = s.length();\n    int[] maxLen = new int[2];\n    dfs(0, n - 1, s, maxLen, new Integer[n][n]);\n    return s.substring(maxLen[0], maxLen[1] + 1);\n}\n\nint dfs(int i, int j, String s, int[] maxLen, Integer[][] memo) {\n    if (i > j) return 0;\n    if (i == j) return 1;\n    if (memo[i][j] != null) return memo[i][j];\n    \n    if (s.charAt(i) == s.charAt(j) && dfs(i + 1, j - 1, s, maxLen, memo) == j - i - 1) {\n        if (j - i > maxLen[1] - maxLen[0]) {\n            maxLen[0] = i;\n            maxLen[1] = j;\n        }\n        memo[i][j] = j - i + 1;\n    } else {\n        memo[i][j] = Math.max(dfs(i + 1, j, s, maxLen, memo), dfs(i, j - 1, s, maxLen, memo));\n    }\n    \n    return memo[i][j];\n}\n*/\n\n\n\n\npublic String longestPalindrome(String s) {\n    int n = s.length(), start = 0, end = 0;\n    boolean[][] dp = new boolean[n][n];\n\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= i; j--) {\n            int gap = j - i;\n\n            dp[i][j] = s.charAt(i) == s.charAt(j) &&\n                    (gap <= 1 || dp[i + 1][j - 1]);\n\n            if (dp[i][j] && gap > end - start) {\n                start = i;\n                end = j;\n            }\n        }\n    }\n\n    return s.substring(start, end + 1);\n}","topicId":13},{"id":181,"position":5,"title":"Interleaving String","difficulty":2,"link":"https://leetcode.com/problems/interleaving-string/\nhttps://www.youtube.com/watch?v=3Rw3p9LrgvE","hint":"* take 2D dP array. ([m + 1][n + 1])\n* set intitial condition dp[0][0] = 0;\n* row represent s2.\n* col represent s1.\n* first row (i, 0) represents s2 characters.\n* first col (0, j) represents s1 characters.\n* any (i, j) represents if the s1 till i  + s2 till j can form string s3 till i + j.\n\nreducing to 1D dp is pretty easy. ","notes":"Revision Dates: 7/12/2023\nLast Revision Notes: solved","solution":"/*\n// Memoization\npublic boolean isInterleave(String s1, String s2, String s3) {\n    int m = s1.length(), n = s2.length(), N = s3.length();\n    if (m + n != N) return false;\n    Boolean[][] memo = new Boolean[m + 1][n + 1];\n    return dfs(m - 1, n - 1, N - 1, s1, s2, s3, memo);\n}\n\nboolean dfs(int i1, int i2, int i3, String s1, String s2, String s3, Boolean[][] memo) {\n    if (i1 < 0 && i2 < 0) return true;\n    if (memo[i1 + 1][i2 + 1] != null) return memo[i1 + 1][i2 + 1];\n\n    boolean possible = false;\n    if (i1 >= 0 && s1.charAt(i1) == s3.charAt(i3)) {\n        possible = possible || dfs(i1 - 1, i2, i3 - 1, s1, s2, s3, memo);\n    }\n\n    if (i2 >= 0 && s2.charAt(i2) == s3.charAt(i3)) {\n        possible = possible || dfs(i1, i2 - 1, i3 - 1, s1, s2, s3, memo);\n    }\n\n    memo[i1 + 1][i2 + 1] = possible;\n    return possible;\n}\n*/\n\n\npublic boolean isInterleave(String s1, String s2, String s3) {\n    int m = s1.length(), n = s2.length(), N = s3.length();\n    if (m + n != N) return false;\n    boolean[] dp = new boolean[n + 1];\n    dp[0] = true;\n    for (int j = 1; j <= n; j++) {\n        dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);\n    }\n\n    for (int i = 1; i <= m; i++) {\n        dp[0] = dp[0] && s1.charAt(i - 1) == s3.charAt(i - 1); // for (i, 0)\n        for (int j = 1; j <= n; j++) {\n            int k = i + j;\n            dp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(k - 1) ||\n                    dp[j - 1] && s2.charAt(j - 1) == s3.charAt(k - 1);\n        }\n    }\n    return dp[n];\n}","topicId":13},{"id":182,"position":6,"title":"Edit Distance","difficulty":2,"link":"https://leetcode.com/problems/edit-distance/\nhttps://www.youtube.com/watch?v=XYi2-LPrwm4","hint":"Base case: \n* if both strings are empty then return 0;\n* if word1 is empty then return word2.length(). (for insert).\n* if word2 is empty then return word1.length(). (for remove).\n\nfor normat case \n* if the chatAt i1 & i2 matches return the previous value.\n* else return 1 + min(replace, delete, insert).\n\n","notes":"Revision Dates: 8/12/2023, 16/01/2024\nLast Revision Notes: Solved","solution":"/*\n// Memoization\npublic int minDistance(String word1, String word2) {\n    int m = word1.length(), n = word2.length();\n    return dfs(m - 1, n - 1, word1, word2, new Integer[m][n]);\n}\n\nint dfs(int i1, int i2, String word1, String word2, Integer[][] memo) {\n    if (i1 == -1) return i2 + 1;\n    if (i2 == -1) return i1 + 1;\n    if (memo[i1][i2] != null) return memo[i1][i2];\n\n    if (word1.charAt(i1) == word2.charAt(i2)) {\n        memo[i1][i2] = dfs(i1 - 1, i2 - 1, word1, word2, memo);\n    } else {\n        int insert = dfs(i1, i2 - 1, word1, word2, memo);\n        int delete = dfs(i1 - 1, i2, word1, word2, memo);\n        int replace = dfs(i1 - 1, i2 - 1, word1, word2, memo);\n        memo[i1][i2] = 1 + Math.min(insert, Math.min(delete, replace));\n    }\n\n    return memo[i1][i2];\n}\n*/\n\npublic int minDistance(String word1, String word2) {\n    int m = word1.length(), n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n    // dp[0][0] = 0 : word1 & word2 is empty then 0 operations needed.\n    // word2 is empty then we need word1 operations.\n    for (int i = 1; i <= m; i++) dp[i][0] = i;\n    // word1 is empty then we need word2 operations\n    for (int j = 1; j <= n; j++) dp[0][j] = j;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                int insert = dp[i][j - 1];\n                int delete = dp[i - 1][j];\n                int replace = dp[i - 1][j - 1];\n                dp[i][j] = 1 + Math.min(insert, Math.min(delete, replace));\n            }\n        }\n    }\n\n    return dp[m][n];\n}","topicId":13},{"id":183,"position":7,"title":"Best Time to Buy and Sell Stock III","difficulty":3,"link":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\nhttps://www.youtube.com/watch?v=-uQGzhYj8BQ","hint":"Two decisions:  if(transactions % 2 == 0) buy else sell\n* buy / sell\n* ignore the day","notes":"Revision Dates: 8/12/2023\nLast Revision Notes: Not able to write tabulation","solution":"public int maxProfit(int[] prices) {\n    int n = prices.length;\n    int[][] dp = new int[n + 1][5];\n    //no need to initialize the dp as base cases are 0;\n    for (int idx = n - 1; idx >= 0; idx--) {\n        for (int transactions = 3; transactions >= 0; transactions--) {\n            int profit = 0;\n            if (transactions % 2 == 0) {\n                //buy\n                profit = dp[idx + 1][transactions + 1] - prices[idx];\n            } else {\n                //sell\n                profit = dp[idx + 1][transactions + 1] + prices[idx];\n            }\n            dp[idx][transactions] = Math.max(profit, dp[idx + 1][transactions]);\n        }\n    }\n    return dp[0][0];\n}","topicId":13},{"id":184,"position":8,"title":"Best Time to Buy and Sell Stock IV","difficulty":3,"link":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/","hint":"same as previous question.\nJust need to change the transactions count as 2 * k.","notes":"Revision Dates: 8/12/2023\nLast Revision Notes: Solved","solution":"public int maxProfit(int k, int[] prices) {\n    int n = prices.length;\n    int[][] dp = new int[n + 1][k * 2 + 1];\n    //no need to initialize the dp as base cases are 0;\n    for (int idx = n - 1; idx >= 0; idx--) {\n        for (int transactions = k * 2 - 1; transactions >= 0; transactions--) {\n            int profit = 0;\n            if (transactions % 2 == 0) {\n                //buy\n                profit = dp[idx + 1][transactions + 1] - prices[idx];\n            } else {\n                //sell\n                profit = dp[idx + 1][transactions + 1] + prices[idx];\n            }\n            dp[idx][transactions] = Math.max(profit, dp[idx + 1][transactions]);\n        }\n    }\n    return dp[0][0];\n}","topicId":13},{"id":187,"position":9,"title":"Maximal Square","difficulty":2,"link":"https://leetcode.com/problems/maximal-square/\nhttps://www.youtube.com/watch?v=6X7Ha2PrDmM","hint":"for any cell (i,j) == 1, is a square if its down, diagonal and right cell is also a square.\nfor calculating the size of square take min(down, diagonal, right) and add 1.","notes":"Revision Dates: 9/12/2023\nLast Revision Notes: Solved","solution":"public int maximalSquare(char[][] matrix) {\n    int m = matrix.length, n = matrix[0].length, max = 0;\n    int[][] dp = new int[m + 1][n + 1];\n    //no need to initialize the dp as base case is 0.\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if (matrix[i][j] == '1') {\n                //min(down, diagonal, right)\n                dp[i][j] = 1 + Math.min(dp[i + 1][j], Math.min(dp[i + 1][j + 1], dp[i][j + 1]));\n                max = Math.max(max, dp[i][j]);\n            }\n        }\n    }\n    return max * max;\n}","topicId":13},{"id":188,"position":1,"title":"Maximum Depth of Binary Tree","difficulty":1,"link":"https://leetcode.com/problems/maximum-depth-of-binary-tree/","hint":"NA","notes":"Revision Dates: 9/12/2023\nLast Revision Notes: Solved","solution":"public int maxDepth(TreeNode root) {\n    if (root == null) return 0;\n    \n    int left = maxDepth(root.left);\n    int right = maxDepth(root.right);\n\n    return 1 + Math.max(left, right);\n}","topicId":24},{"id":189,"position":2,"title":"Same Tree","difficulty":1,"link":"https://leetcode.com/problems/same-tree/description/","hint":"NA","notes":"Revision Dates: 9/12/2023\nLast Revision Notes: Solved","solution":"public boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    else if (p != null && q == null || p == null && q != null || p.val != q.val) return false;\n\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}","topicId":24},{"id":190,"position":3,"title":"Invert Binary Tree","difficulty":1,"link":"https://leetcode.com/problems/invert-binary-tree/","hint":"Introduce variables to store left and right.","notes":"Revision Dates: 9/12/2023\nLast Revision Notes: Solved","solution":"public TreeNode invertTree(TreeNode root) {\n    if (root == null) return null;\n\n    TreeNode left = root.left, right = root.right;\n    root.left = invertTree(right);\n    root.right = invertTree(left);\n\n    return root;\n}","topicId":24},{"id":191,"position":4,"title":"Symmetric Tree","difficulty":1,"link":"https://leetcode.com/problems/symmetric-tree/","hint":"Use function with two parameters.\nCompare left-left with right-right and left-right with right-left.","notes":"Revision Dates: 9/12/2023\nLast Revision Notes: Solved","solution":"public boolean isSymmetric(TreeNode root) {\n    return helper(root.left, root.right);\n}\n\nprivate boolean helper(TreeNode left, TreeNode right) {\n    if (left == null && right == null) return true;\n    else if (left != null && right == null ||\n            left == null && right != null ||\n            left.val != right.val) return false;\n\n    return helper(left.left, right.right) && helper(left.right, right.left);\n}","topicId":24},{"id":192,"position":5,"title":"Construct Binary Tree from Preorder and Inorder Traversal","difficulty":2,"link":"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/","hint":"* For creating a unique tree we need either IN and PRE order or IN and POST order. PRE and POST cannot create unique tree.\n* From preorder we can get the root element, i.e first element (i1) is root element.\n* Then find the left and right elements from inorder. ie all the elements to the left are for left child and all the elements to the right is for right child.\n* Similarly we can get the preorder for left and right child, after first element, elements for left child starts (you can get the count from inorder traversal) and after that all the elements belongs to right child.","notes":"Revision Dates: 9/12/2023\nLast Revision Notes: Not solved","solution":"public TreeNode buildTree(int[] preorder, int[] inorder) {\n    int m = preorder.length, n = inorder.length;\n    HashMap<Integer, Integer> inOrder = new HashMap<>();\n    for (int i = 0; i < n; i++) {\n        inOrder.put(inorder[i], i);\n    }\n    return buildTree(preorder, inOrder, 0, m - 1, 0, n - 1);\n}\n\nprivate TreeNode buildTree(int[] preorder, HashMap<Integer, Integer> inorder, \n                                              int i1, int j1, int i2, int j2) {\n    if (i1 > j1) return null;\n\n    TreeNode root = new TreeNode(preorder[i1]);\n\n    int inorderIdx = inorder.get(preorder[i1]);\n    int leftNodes = inorderIdx - i2;\n\n    root.left = buildTree(preorder, inorder, i1 + 1, i1 + leftNodes, i2, inorderIdx - 1);\n    root.right = buildTree(preorder, inorder, i1 + leftNodes + 1, j1, inorderIdx + 1, j2);\n\n\n    return root;\n}","topicId":24},{"id":193,"position":6,"title":"Construct Binary Tree from Inorder and Postorder Traversal","difficulty":2,"link":"https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/","hint":"Same as previous, just modify accordingly for postorder.","notes":"Revision Dates: 9/12/2023\nLast Revision Notes: Solved","solution":"public TreeNode buildTree(int[] inorder, int[] postorder) {\n    int m = postorder.length, n = inorder.length;\n    HashMap<Integer, Integer> inOrder = new HashMap<>();\n    for (int i = 0; i < n; i++) {\n        inOrder.put(inorder[i], i);\n    }\n    return buildTree(postorder, inOrder, 0, m - 1, 0, n - 1);\n}\n\nprivate TreeNode buildTree(int[] postorder, HashMap<Integer, Integer> inorder, \n                                                int i1, int j1, int i2, int j2) {\n    if (i1 > j1) return null;\n\n    TreeNode root = new TreeNode(postorder[j1]);\n\n    int inorderIdx = inorder.get(postorder[j1]);\n    int leftNodes = inorderIdx - i2;\n\n    root.left = buildTree(postorder, inorder, i1, i1 + leftNodes - 1, i2, inorderIdx - 1);\n    root.right = buildTree(postorder, inorder, i1 + leftNodes, j1 - 1, inorderIdx + 1, j2);\n\n\n    return root;\n}","topicId":24},{"id":195,"position":7,"title":"Populating Next Right Pointers in Each Node II","difficulty":2,"link":"https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/\nhttps://www.youtube.com/watch?v=U4hFQCa1Cq0","hint":"* We have to recursively call right first because we need to connect all the right elements first.\n* We need to recursively find the nextParallelNode because when immediate next parent doesn't have any child.","notes":"Revision Dates: 10/12/2023\nLast Revision Notes: Not solved without BFS.","solution":"public Node connect(Node root) {\n    if (root == null) return root;\n\n    if (root.left != null) {\n        root.left.next = root.right != null ? root.right : findParallelNode(root.next);\n    }\n\n    if (root.right != null) {\n        root.right.next = findParallelNode(root.next);\n    }\n\n\n    connect(root.right);\n    connect(root.left);\n\n    return root;\n}\n\nprivate Node findParallelNode(Node root) {\n    if (root == null) return null;\n    if (root.left != null) return root.left;\n    if (root.right != null) return root.right;\n    return findParallelNode(root.next);\n}","topicId":24},{"id":197,"position":8,"title":"Flatten Binary Tree to Linked List","difficulty":2,"link":"https://leetcode.com/problems/flatten-binary-tree-to-linked-list/\nhttps://www.youtube.com/watch?v=sWf7k1x9XR4\nhttps://www.youtube.com/watch?v=wGXB9OWhPTg","hint":"Learn Morris inorder traaversal.\nAlgo: \n* Start with curr = root and iterate till curr == null.\n* if curr left == null do nothing\n* else find the right-most element of curr's left and point's its right to curr's right.\n** Modify the curr's right to point it to curr's left, make curr's left null.\n* Keep moving curr to curr's right.","notes":"Revision Dates: 10/12/2023\nLast Revision Notes: Not able to wirte morris logic","solution":"public void flatten(TreeNode root) {\n    TreeNode curr = root;\n    while (curr != null) {\n        if (curr.left != null) {\n            TreeNode tail = curr.left;\n            while (tail.right != null) {\n                tail = tail.right;\n            }\n\n            tail.right = curr.right;\n            curr.right = curr.left;\n            curr.left = null;\n        }\n        \n        curr = curr.right;\n    }\n}","topicId":24},{"id":198,"position":9,"title":"Path Sum","difficulty":1,"link":"https://leetcode.com/problems/path-sum/\n","hint":"NA","notes":"Revision Dates: 11/12/2023\nLast Revision Notes: Solved","solution":"public boolean hasPathSum(TreeNode root, int targetSum) {\n    if (root == null) return false;\n    if (root.left == null && root.right == null) return root.val == targetSum;\n    \n    return hasPathSum(root.left, targetSum - root.val) ||\n            hasPathSum(root.right, targetSum - root.val);\n}","topicId":24},{"id":199,"position":10,"title":"Sum Root to Leaf Numbers","difficulty":2,"link":"https://leetcode.com/problems/sum-root-to-leaf-numbers/","hint":"NA","notes":"Revision Dates: 11/12/2023\nLast Revision Notes: Solved","solution":"public int sumNumbers(TreeNode root) {\n    return sumNumbers(root, 0);\n}\n\nprivate int sumNumbers(TreeNode root, int sum) {\n    if (root == null) return 0;\n    if (root.left == null && root.right == null) return sum * 10 + root.val;\n\n    int sumNumbers = 0;\n    if (root.left != null) sumNumbers += sumNumbers(root.left, sum * 10 + root.val);\n    if (root.right != null) sumNumbers += sumNumbers(root.right, sum * 10 + root.val);\n\n    return sumNumbers;\n}","topicId":24},{"id":201,"position":11,"title":"Binary Tree Maximum Path Sum","difficulty":3,"link":"https://leetcode.com/problems/binary-tree-maximum-path-sum/\nhttps://www.youtube.com/watch?v=Hr5cWUld4vU","hint":"* Path means it can only split once. Spliting means considering both left and right subtree.\nAlgorithm:\n* Take one global variable maxPathSum and assign it to root.val.\n* Do dfs.\n* Try splitting at every node and update the maxPathSum.\n* return the root.value + Math.max(leftPath, rightPath) because we cannot split two times.\n","notes":"Revision Dates: 11/12/2023\nLast Revision Notes: Not Solved","solution":"public int maxPathSum(TreeNode root) {\n    int[] maxPathSum = new int[]{root.val};\n    maxPathSum(root, maxPathSum);\n    return maxPathSum[0];\n}\n\npublic int maxPathSum(TreeNode root, int[] maxPathSum) {\n    if (root == null) return 0;\n\n    //Taking max of path and 0 to avoid multiple max checks.\n    int leftPath = Math.max(maxPathSum(root.left, maxPathSum), 0);\n    int rightPath = Math.max(maxPathSum(root.right, maxPathSum), 0);\n\n    //we cannot return this value because we have created new path.\n    maxPathSum[0] = Math.max(root.val + leftPath + rightPath, maxPathSum[0]);\n\n    return root.val + Math.max(leftPath, rightPath);\n}","topicId":24},{"id":202,"position":12,"title":"Binary Search Tree Iterator","difficulty":2,"link":"https://leetcode.com/problems/binary-search-tree-iterator/","hint":"Used Morris inorder traversal\nAlgo: \n* Start with curr == root and keep iterating while curr != null.\n* If left is null, process root and move curr to its right.\n* else find the rightMostNode of curr's left and attach rightMostNode's right to curr. And move curr to its left.\n\nNote: If curr's left's rightMostNode is already pointing to curr, then it means that we have already processed the left node, process root and move curr to its right.\n","notes":"Revision Dates: 11/12/2023\nLast Revision Notes: Solved","solution":"class BSTIterator {\n    TreeNode curr;\n    public BSTIterator(TreeNode root) {\n        curr = root;\n    }\n    \n    public int next() {\n        Integer val = null;\n        \n        if(curr.left == null){\n            val = curr.val;\n            curr = curr.right;\n        } else {\n            TreeNode rightMost = curr.left;\n            while(rightMost.right != null && rightMost.right != curr)\n                rightMost = rightMost.right;\n\n            if(rightMost.right == curr){\n                rightMost.right = null;\n                val = curr.val;\n                curr = curr.right;\n            } else {\n                rightMost.right = curr;\n                curr = curr.left;\n            }\n        }\n        \n        if(val == null) val = next();\n        return val;\n    }\n    \n    public boolean hasNext() {\n        return curr != null;\n    }\n}","topicId":24},{"id":203,"position":14,"title":"Lowest Common Ancestor of a Binary Tree","difficulty":2,"link":"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/","hint":"Algo:\n* if root == p or q then no need to check its child because it is either Lowest Common Ancestor or one of the result.\n* If left and right are not null then root is the Lowest Common Ancestor\n* else we can send either of left or right which is not null\n","notes":"Revision Dates: 11/12/2023\nLast Revision Notes: Solved","solution":"public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || root.val == p.val || root.val == q.val) return root;\n\n    TreeNode left = lowestCommonAncestor(root.left, p, q);\n    TreeNode right = lowestCommonAncestor(root.right, p, q);\n\n    return left != null && right != null ? root : (left != null ? left : right);\n}","topicId":24},{"id":204,"position":13,"title":"Count Complete Tree Nodes","difficulty":2,"link":"https://leetcode.com/problems/count-complete-tree-nodes/\nhttps://www.youtube.com/watch?v=u-yWemKGWO0","hint":"Algo:\n* find the left and right height.\n* if left and right are equal means tree is complete, ie node count = 2^h - `1;\n* else repeat same for left and right and add 1.","notes":"Revision Dates: 11/12/2023\nLast Revision Notes: Not solved in T:O(log^2 N), S:O(log(n))","solution":"public int countNodes(TreeNode root) {\n    if (root == null) return 0;\n    int left = findHeight(root, true);\n    int right = findHeight(root, false);\n\n    if (left == right) return (1 << left) - 1;\n    else return 1 + countNodes(root.left) + countNodes(root.right);\n}\n\nint findHeight(TreeNode root, boolean left) {\n    if (root == null) return 0;\n    else if (left) return 1 + findHeight(root.left, left);\n    else return 1 + findHeight(root.right, left);\n}","topicId":24},{"id":205,"position":1,"title":"Binary Tree Right Side View","difficulty":2,"link":"https://leetcode.com/problems/binary-tree-right-side-view/\nhttps://www.youtube.com/watch?v=KV4mRzTjlAk","hint":"Algo: Root -> Right -> Left treversal.\n* if the level is visited first time, add the root.val to list.\n\n","notes":"Revision Dates: 12/12/2023\nLast Revision Notes: Not able to think about recursive solution.","solution":"public List<Integer> rightSideView(TreeNode root) {\n    List<Integer> list = new ArrayList<>(100);\n    dfs(root, list, 0);\n    return list;\n}\n\nvoid dfs(TreeNode root, List<Integer> list, int level) {\n    if (root == null) return;\n    //if we are visiting the level first time add the root.val to list\n    if (level == list.size()) list.add(root.val);\n\n    dfs(root.right, list, level + 1);\n    dfs(root.left, list, level + 1);\n}","topicId":25},{"id":206,"position":2,"title":"Average of Levels in Binary Tree","difficulty":1,"link":"https://leetcode.com/problems/average-of-levels-in-binary-tree/","hint":"NA","notes":"Revision Dates: 12/12/2023\nLast Revision Notes: Solved","solution":"public List<Double> averageOfLevels(TreeNode root) {\n    List<Double> averages = new LinkedList<>();\n    Queue<TreeNode> q = new LinkedList<>();\n    if (root != null) q.add(root);\n\n    while (!q.isEmpty()) {\n        double sum = 0;\n        int size = q.size();\n        for (int i = 0; i < size; i++) {\n            TreeNode top = q.poll();\n            sum += top.val;\n            if (top.left != null)  q.offer(top.left);\n            if (top.right != null) q.offer(top.right);\n        }\n        averages.add(sum / size);\n    }\n\n    return averages;\n}","topicId":25},{"id":207,"position":3,"title":"Binary Tree Level Order Traversal","difficulty":2,"link":"https://leetcode.com/problems/binary-tree-level-order-traversal/","hint":"Perform pre-order traversal and if visiting the level first time, create a new arraylist for level.","notes":"Revision Dates: 12/12/2023\nLast Revision Notes: Not able to think about recursive solution.","solution":"public List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> levels = new ArrayList<>();\n    dfs(root, 0, levels);\n    return levels;\n}\n\nvoid dfs(TreeNode root, int level, List<List<Integer>> levels) {\n    if (root == null) return;\n    //if visiting the level first time, create a new arraylist for level.\n    if (levels.size() == level) levels.add(new ArrayList<>());\n\n    levels.get(level).add(root.val);\n\n    dfs(root.left, level + 1, levels);\n    dfs(root.right, level + 1, levels);\n}","topicId":25},{"id":208,"position":4,"title":"Binary Tree Zigzag Level Order Traversal","difficulty":2,"link":"https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/","hint":"Use LinkedList and based on level % 2, addLast or addFirsrt.","notes":"Revision Dates: 12/12/2023\nLast Revision Notes: Solved","solution":"public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    List<List<Integer>> levels = new LinkedList<>();\n    dfs(root, levels, 0);\n    return levels;\n}\n\nvoid dfs(TreeNode root, List<List<Integer>> levels, int level) {\n    if (root == null) return;\n    if (levels.size() == level) levels.add(new LinkedList<>());\n\n    LinkedList<Integer> levelList = (LinkedList<Integer>) levels.get(level);\n    if (level % 2 == 0) levelList.addLast(root.val);\n    else levelList.addFirst(root.val);\n\n    dfs(root.left, levels, level + 1);\n    dfs(root.right, levels, level + 1);\n}","topicId":25},{"id":210,"position":1,"title":"Minimum Absolute Difference in BST","difficulty":1,"link":"https://leetcode.com/problems/minimum-absolute-difference-in-bst/\nhttps://www.youtube.com/watch?v=joxx4hTYwcw","hint":"Inorder traversal in BST returns sorted value in ascending order.\nIf the value is sorted then we only need to compare the adjacent element.","notes":"Revision Dates: 12/12/2023\nLast Revision Notes: Not solved","solution":"public int getMinimumDifference(TreeNode root) {\n    // arr[0] = lastNodeValue, arr[1] = minimumDifference\n    int[] arr = {-1, Integer.MAX_VALUE};\n    dfs(root, arr);\n    return arr[1];\n}\n\nvoid dfs(TreeNode root, int[] arr) {\n    if (root == null) return;\n    \n    dfs(root.left, arr);\n\n    if (arr[0] != -1) arr[1] = Math.min(arr[1], root.val - arr[0]);\n    arr[0] = root.val;\n\n    dfs(root.right, arr);\n}","topicId":26},{"id":213,"position":2,"title":"Kth Smallest Element in a BST","difficulty":2,"link":"https://leetcode.com/problems/kth-smallest-element-in-a-bst/","hint":"Do Inorder traversal and if index == k return the result.","notes":"Revision Dates: 13/12/2023\nLast Revision Notes: Solved","solution":"public int kthSmallest(TreeNode root, int k) {\n    // {kth_value, index}\n    int[] result = {0, 0};\n    dfs(root, k, result);\n    return result[0];\n}\n\nvoid dfs(TreeNode root, int k, int[] result) {\n    if (root == null || k == result[1]) return;\n    dfs(root.left, k, result);\n\n    result[1]++;\n    if (k == result[1]) result[0] = root.val;\n    \n    dfs(root.right, k, result);\n}","topicId":26},{"id":214,"position":3,"title":"Validate Binary Search Tree","difficulty":2,"link":"https://leetcode.com/problems/validate-binary-search-tree/","hint":"Uese the property that is : \n* root is always greater than the maximum of all the left subtree nodes.\n* root is always smaller than the minimum of all the right subtree nodes.\n\nAlgo: \nperfor inorder traversal and if the prev is >= curr then the tree is not a BST.","notes":"Revision Dates: 13/12/2023\nLast Revision Notes: Solved","solution":"public boolean isValidBST(TreeNode root) {\n    return dfs(root, new Integer[1]);\n}\n\nboolean dfs(TreeNode node, Integer[] prev) {\n    if (node == null) return true;\n\n    boolean left = dfs(node.left, prev);\n\n    boolean root = prev[0] == null || node.val > prev[0];\n    prev[0] = node.val;\n\n    boolean right = dfs(node.right, prev);\n\n    return left && root && right;\n}","topicId":26},{"id":215,"position":1,"title":"Number of Islands","difficulty":2,"link":"https://leetcode.com/problems/number-of-islands/","hint":"Use Multi-dimensional DFS.","notes":"Revision Dates: 13/12/2023\nLast Revision Notes: Solved","solution":"public int numIslands(char[][] grid) {\n    short[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    boolean[][] visited = new boolean[grid.length][grid[0].length];\n\n    int count = 0;\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (visited[i][j] || grid[i][j] == '0') continue;\n            count++;\n            dfs(grid, visited, directions, i, j);\n        }\n    }\n    return count;\n}\n\nvoid dfs(char[][] grid, boolean[][] visited, short[][] directions, int i, int j) {\n    if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length ||\n            grid[i][j] == '0' || visited[i][j]) return;\n\n    visited[i][j] = true;\n    for (short[] direction : directions) {\n        dfs(grid, visited, directions, i + direction[0], j + direction[1]);\n    }\n}","topicId":27},{"id":216,"position":2,"title":"Surrounded Regions","difficulty":2,"link":"https://leetcode.com/problems/surrounded-regions/","hint":"Call dfs on all the 'O' that is located on boundary that marks all the visited components as 'Z'\n\nThen convert all the 'O' to X and 'Z' to 'O.","notes":"Revision Dates: 15/12/2023\nLast Revision Notes: Solved","solution":"public void solve(char[][] board) {\n    int m = board.length, n = board[0].length;\n\n    for (int i = 0; i < m; i++) {\n        if (board[i][0] == 'O') dfs(board, i, 0);\n        if (board[i][n - 1] == 'O') dfs(board, i, n - 1);\n    }\n\n    for (int j = 1; j < n - 1; j++) {\n        if (board[0][j] == 'O') dfs(board, 0, j);\n        if (board[m - 1][j] == 'O') dfs(board, m - 1, j);\n    }\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (board[i][j] == 'Z') board[i][j] = 'O';\n            else if (board[i][j] == 'O') board[i][j] = 'X';\n        }\n    }\n}\n\nvoid dfs(char[][] board, int i, int j) {\n    if (i < 0 || j < 0 || i >= board.length || j >= board[0].length ||\n            board[i][j] == 'X' || board[i][j] == 'Z') return;\n\n    board[i][j] = 'Z';\n\n    dfs(board, i - 1, j);\n    dfs(board, i + 1, j);\n    dfs(board, i, j - 1);\n    dfs(board, i, j + 1);\n}","topicId":27},{"id":217,"position":3,"title":"Clone Graph","difficulty":2,"link":"https://leetcode.com/problems/clone-graph/","hint":"try dfs approach","notes":"Revision Dates: 16/12/2023\nLast Revision Notes: Not able to think about dfs solution.","solution":"public Node cloneGraph(Node node) {\n    if (node == null) return null;\n    Node[] visited = new Node[101];\n    dfs(node, new Node(node.val), visited);\n    return visited[node.val];\n}\n\nvoid dfs(Node node, Node copied, Node[] visited) {\n    visited[node.val] = copied;\n\n    for (Node neighbor : node.neighbors) {\n        if (visited[neighbor.val] == null) {\n            dfs(neighbor, new Node(neighbor.val), visited);\n        }\n        copied.neighbors.add(visited[neighbor.val]);\n    }\n}","topicId":27},{"id":218,"position":4,"title":"Evaluate Division","difficulty":2,"link":"https://leetcode.com/problems/evaluate-division/\nhttps://www.youtube.com/watch?v=Uei1fwDoyKk","hint":"Create directed weighted graph with two edges (a -> b = val , b -> a = 1 / val ).\nThen perform dfs to check if we can get to the dest.","notes":"Revision Dates: 16/12/2023\nLast Revision Notes: Not able to write dfs logic properly.","solution":"double dfs(String src, String dest, HashMap<String, List<Edge>> graph, HashSet<String> visited) {\n    if (!graph.containsKey(src) || !graph.containsKey(dest)) return -1.0;\n    if (src.equals(dest)) return 1.0;\n\n    visited.add(src);\n    for (Edge edge : graph.get(src)) {\n        if (visited.contains(edge.vertex)) continue;\n        double weight = dfs(edge.vertex, dest, graph, visited);\n        if (weight != -1) return weight * edge.weight;\n    }\n    return -1;\n}\n\npublic double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n    HashMap<String, List<Edge>> graph = new HashMap<>();\n    //creating a directed graph: source -> dest = value[i] & dest -> source = 1 / value[i]\n    for (int i = 0; i < values.length; i++) {\n        double value = values[i];\n        List<String> equation = equations.get(i);\n        String src = equation.get(0), dest = equation.get(1);\n\n        List<Edge> srcToDest = graph.getOrDefault(src, new LinkedList<>());\n        srcToDest.add(new Edge(value, dest));\n        graph.put(src, srcToDest);\n\n        List<Edge> destToSrc = graph.getOrDefault(dest, new LinkedList<>());\n        destToSrc.add(new Edge(1.0 / value, src));\n        graph.put(dest, destToSrc);\n    }\n\n    double[] result = new double[queries.size()];\n    for (int i = 0; i < result.length; i++) {\n        List<String> query = queries.get(i);\n        result[i] = dfs(query.get(0), query.get(1), graph, new HashSet<>());\n    }\n    return result;\n}\n\nclass Edge {\n    double weight;\n    String vertex;\n\n    Edge(double weight, String vertex) {\n        this.weight = weight;\n        this.vertex = vertex;\n    }\n}","topicId":27},{"id":220,"position":5,"title":"Course Schedule","difficulty":2,"link":"https://leetcode.com/problems/course-schedule/","hint":"Create a graph with key as course and value as pre requisite.\nCreate one visited array to keep track of if cycle exists or not.\nAlgo:\n* Call dfs for every course (as there might be unconnected graphs)\n* If the course is not present in graph, then it means that course has already been taken, return true.\n* if the course is in visited, then it means that coures cannot be completed i.e., cycle, return false.\n* then visit the course.\n* call dfs for every dependency\n* unvisit the course if completed and remove from graph.","notes":"Revision Dates: 16/12/2023\nLast Revision Notes: Not able to write DFS Algorithm.","solution":"public boolean canFinish(int numCourses, int[][] prerequisites) {\n    HashMap<Integer, List<Integer>> graph = new HashMap<>();\n\n    for (int i = 0; i < numCourses; i++) graph.put(i, new ArrayList<>());\n\n    for (int[] edge : prerequisites) graph.get(edge[0]).add(edge[1]);\n\n    boolean[] visited = new boolean[numCourses];\n\n    for (int i = 0; i < numCourses; i++) {\n        if (!dfs(i, visited, graph)) return false;\n    }\n\n    return true;\n}\n\nboolean dfs(int cource, boolean[] visited, HashMap<Integer, List<Integer>> graph) {\n    if (!graph.containsKey(cource)) return true;\n    if (visited[cource]) return false;\n\n    visited[cource] = true;\n    List<Integer> dependencies = graph.get(cource);\n    for (int dependency : dependencies) {\n        if (!dfs(dependency, visited, graph)) return false;\n    }\n\n    visited[cource] = false;\n    graph.remove(cource);\n    return true;\n}","topicId":27},{"id":221,"position":6,"title":"Course Schedule II","difficulty":2,"link":"https://leetcode.com/problems/course-schedule-ii/\nhttps://www.youtube.com/watch?v=73sneFXuTEg","hint":"Kahn's Algorithm\n* Find indegree of all the vertex. (no of incoming edges)\n* Add all the vertex whose inDegree is 0 to the queue.\n* Start processing the queue.\n* Add the popped course to the schedule.\n* For the the dependency of popped course, reduce the inDegree by 1 and after reducing if inDegree == 0 then add it to queue.\n","notes":"Revision Dates: 16/12/2023\nLast Revision Notes: Solved","solution":"public int[] findOrder(int numCourses, int[][] prerequisites) {\n    int[] inDegree = new int[numCourses];\n    ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\n    for (int i = 0; i < numCourses; i++) graph.add(new ArrayList<>());\n    for (int[] edge : prerequisites) {\n        inDegree[edge[1]]++;\n        graph.get(edge[0]).add(edge[1]);\n    }\n\n    int idx = numCourses - 1;\n    int[] schedule = new int[numCourses];\n    Queue<Integer> queue = new LinkedList<>();\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) queue.add(i);\n    }\n\n    while (!queue.isEmpty()) {\n        int course = queue.poll();\n        schedule[idx--] = course;\n        for (int dependency : graph.get(course)) {\n            inDegree[dependency]--;\n            if (inDegree[dependency] == 0) queue.offer(dependency);\n        }\n    }\n\n    return idx == -1 ? schedule : new int[0];\n}","topicId":27},{"id":223,"position":1,"title":"Snakes and Ladders","difficulty":2,"link":"https://leetcode.com/problems/snakes-and-ladders/","hint":"We can use pair class for storing levels, instead of using null.","notes":"Revision Dates: 17/12/2023\nLast Revision Notes: NA","solution":"public int snakesAndLadders(int[][] board) {\n    int n = board.length, N = n * n;\n    //Pair of num and bfs level\n    Queue<Pair> queue = new LinkedList<>();\n    boolean[] visited = new boolean[N];\n    queue.add(new Pair(1, 0));\n    while (!queue.isEmpty()) {\n        Pair curr = queue.remove();\n        if (visited[curr.a]) continue;\n        visited[curr.a] = true;\n\n        for (int num = curr.a + 1, i = 1; num <= N && i <= 6; num++, i++) {\n            Pair idx = numToIndex(num, n);\n            int next = board[idx.a][idx.b] == -1 ? num : board[idx.a][idx.b];\n            \n            if (next == N) return curr.b + 1;\n            else queue.add(new Pair(next, curr.b + 1));\n        }\n\n    }\n\n    return -1;\n}\n\n//Pair of matrix index i, j.\nPair numToIndex(int num, int n) {\n    int row = (num - 1) / n, col = (num - 1) % n;\n    col = row % 2 == 0 ? col : n - col - 1;\n    row = n - row - 1;\n    return new Pair(row, col);\n}\n\nclass Pair {\n    int a, b;\n\n    Pair(int a, int b) {\n        this.a = a;\n        this.b = b;\n    }\n}","topicId":28},{"id":224,"position":2,"title":"Minimum Genetic Mutation","difficulty":2,"link":"https://leetcode.com/problems/minimum-genetic-mutation/","hint":"NA","notes":"Revision Dates: 17/12/2023\nLast Revision Notes: Solved","solution":"public int minMutation(String startGene, String endGene, String[] bank) {\n    Queue<Pair> queue = new LinkedList<>();\n    HashSet<String> visited = new HashSet<>();\n    queue.add(new Pair(startGene, 0));\n    while (!queue.isEmpty()) {\n        Pair gene = queue.remove();\n        if (visited.contains(gene.value)) continue;\n        visited.add(gene.value);\n\n        for (String nextGene : bank) {\n            if (visited.contains(nextGene) || getMutationCount(gene.value, nextGene) > 1) continue;\n            if (nextGene.equals(endGene)) return gene.level + 1;\n            queue.add(new Pair(nextGene, gene.level + 1));\n        }\n    }\n    return -1;\n}\n\nint getMutationCount(String a, String b) {\n    int count = 0;\n    for (int i = 0; i < 8; i++) {\n        if (a.charAt(i) != b.charAt(i)) count++;\n    }\n    return count;\n}\n\nclass Pair {\n    String value;\n    int level;\n\n    Pair(String value, int level) {\n        this.value = value;\n        this.level = level;\n    }\n}","topicId":28},{"id":225,"position":3,"title":"Word Ladder","difficulty":3,"link":"https://leetcode.com/problems/word-ladder/\nhttps://www.youtube.com/watch?v=tRPda0rcf8E","hint":"Try for every possible generation [from a to z}.\nUse set as visited in reverse way, means if set contains word then its not visited.","notes":"Revision Dates: 17/12/2023\nLast Revision Notes: Solved","solution":"public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    HashSet<String> set = new HashSet<>(wordList);\n    set.add(beginWord);\n    if (!set.contains(endWord)) return 0;\n\n    Queue<String> queue = new LinkedList<>();\n    int n = beginWord.length(), level = 1;\n    queue.add(beginWord);\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        \n        for (int i = 0; i < size; i++) {\n            String transformation = queue.remove();\n            if (set.contains(transformation)) {\n                set.remove(transformation);\n                StringBuilder temp = new StringBuilder(transformation);\n                for (int idx = 0; idx < n; idx++) {\n                    char previous = temp.charAt(idx);\n                    for (char letter = 'a'; letter <= 'z'; letter++) {\n                        temp.setCharAt(idx, letter);\n                        String nextTransformation = temp.toString();\n                        if (nextTransformation.equals(endWord)) return level + 1;\n                        if (set.contains(nextTransformation)) queue.add(nextTransformation);\n                    }\n                    temp.setCharAt(idx, previous);\n                }\n            }\n        }\n        \n        level++;\n    }\n    return 0;\n}","topicId":28},{"id":226,"position":1,"title":"Ransom Note","difficulty":1,"link":"https://leetcode.com/problems/ransom-note/","hint":"NA","notes":"Revision Dates: 17/12/2023\nLast Revision Notes: Solved","solution":"public boolean canConstruct(String ransomNote, String magazine) {\n    int m = ransomNote.length(), n = magazine.length();\n    int[] magazineMap = new int[26];\n\n    for (int i = 0; i < n; i++) {\n        magazineMap[magazine.charAt(i) - 'a']++;\n    }\n\n    for (int i = 0; i < m; i++) {\n        if (--magazineMap[ransomNote.charAt(i) - 'a'] == -1) {\n            return false;\n        }\n    }\n\n    return true;\n}","topicId":29},{"id":227,"position":2,"title":"Isomorphic Strings","difficulty":1,"link":"https://leetcode.com/problems/isomorphic-strings/","hint":"NA","notes":"Revision Dates: 17/12/2023\nLast Revision Notes: Solved","solution":"public boolean isIsomorphic(String s, String t) {\n    int m = s.length(), n = t.length();\n    if (m != n) return false;\n\n    char[] sMap = new char[128];\n    char[] tMap = new char[128];\n    \n    for (int i = 0; i < n; i++) {\n        char a = s.charAt(i), b = t.charAt(i);\n        if (sMap[a] == 0) sMap[a] = b;\n        if (tMap[b] == 0) tMap[b] = a;\n        if (sMap[a] != b || tMap[b] != a) return false;\n    }\n\n    return true;\n}","topicId":29},{"id":228,"position":3,"title":"Word Pattern","difficulty":1,"link":"https://leetcode.com/problems/word-pattern/","hint":"NA","notes":"Revision Dates: 17/12/2023\nLast Revision Notes: Solved","solution":"public boolean wordPattern(String pattern, String s) {\n    char[] letters = pattern.toCharArray();\n    String[] words = s.split(\" \");\n    int m = letters.length, n = words.length;\n    if (m != n) return false;\n\n    HashMap<Character, String> lettersMap = new HashMap<>();\n    HashMap<String, Character> wordsMap = new HashMap<>();\n\n    for (int i = 0; i < n; i++) {\n        char letter = letters[i];\n        String word = words[i];\n        if (!lettersMap.containsKey(letter)) lettersMap.put(letter, word);\n        if (!wordsMap.containsKey(word)) wordsMap.put(word, letter);\n        if (wordsMap.get(word) != letter || !lettersMap.get(letter).equals(word)) return false;\n    }\n\n    return true;\n\n}","topicId":29},{"id":229,"position":4,"title":"Valid Anagram","difficulty":1,"link":"https://leetcode.com/problems/valid-anagram/","hint":"NA","notes":"Revision Dates: 17/12/2023\nLast Revision Notes: Solved","solution":"public boolean isAnagram(String s, String t) {\n    int m = s.length(), n = t.length();\n    if (m != n) return false;\n\n    int[] freq = new int[26];\n    for (int i = 0; i < n; i++) {\n        freq[s.charAt(i) - 'a']++;\n        freq[t.charAt(i) - 'a']--;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] != 0) return false;\n    }\n\n    return true;\n}","topicId":29},{"id":230,"position":5,"title":"Group Anagrams","difficulty":2,"link":"https://leetcode.com/problems/group-anagrams/","hint":"Take key as frequency of string.","notes":"Revision Dates: 17/12/2023\nLast Revision Notes: Solved","solution":"public List<List<String>> groupAnagrams(String[] strs) {\n    HashMap<String, List<String>> map = new HashMap<>();\n    for (String str : strs) {\n        String key = findFrequency(str);\n        map.computeIfAbsent(key, value -> new ArrayList<>()).add(str);\n    }\n\n    List<List<String>> groups = new ArrayList<>();\n    map.forEach((k, v) -> {\n        groups.add(v);\n    });\n\n    return groups;\n}\n\nString findFrequency(String str) {\n    char[] freq = new char[26];\n    for (char c : str.toCharArray()) freq[c - 'a']++;\n    return String.valueOf(freq);\n}","topicId":29},{"id":231,"position":6,"title":"Two Sum","difficulty":1,"link":"https://leetcode.com/problems/two-sum/","hint":"Start checking when filling the map to avoid using number twice.","notes":"Revision Dates: 18/12/2023\nLast Revision Notes: Solved","solution":"public int[] twoSum(int[] nums, int target) {\n    HashMap<Integer, Integer> map = new HashMap<>();\n    \n    for (int i = 0; i < nums.length; i++) {\n        if (map.containsKey(target - nums[i])) {\n            return new int[]{map.get(target - nums[i]), i};\n        } else {\n            map.put(nums[i], i);\n        }\n    }\n    \n    return new int[0];\n}","topicId":29},{"id":232,"position":7,"title":"Happy Number","difficulty":1,"link":"https://leetcode.com/problems/happy-number/","hint":"If the number occurs twice then it means that the number can't end at 1.","notes":"Revision Dates: 18/12/2023\nLast Revision Notes: Solved","solution":"public boolean isHappy(int n) {\n    HashSet<Integer> set = new HashSet<>();\n    while (!set.contains(n)) {\n        set.add(n);\n        int sum = 0;\n        while (n > 0) {\n            int digit = n % 10;\n            sum += digit * digit;\n            n = n / 10;\n        }\n        n = sum;\n    }\n    return n == 1;\n}","topicId":29},{"id":233,"position":8,"title":"Contains Duplicate II","difficulty":1,"link":"https://leetcode.com/problems/contains-duplicate-ii/","hint":"No need to calculate absolute value because map.get(num) is always smaller than i.","notes":"Revision Dates: 18/12/2023\nLast Revision Notes: Solved","solution":"public boolean containsNearbyDuplicate(int[] nums, int k) {\n    HashMap<Integer, Integer> map = new HashMap<>();\n    int i = 0;\n    for (int num : nums) {\n        if (map.containsKey(num) && i - map.get(num) <= k) {\n            return true;\n        }\n        map.put(num, i++);\n    }\n    return false;\n}","topicId":29},{"id":234,"position":9,"title":"Longest Consecutive Sequence","difficulty":2,"link":"https://leetcode.com/problems/longest-consecutive-sequence/","hint":"For any number, check its consecutive numbers before and after.","notes":"Revision Dates: 18/12/2023\nLast Revision Notes: Solved","solution":"public int longestConsecutive(int[] nums) {\n    int longestSequence = 0;\n    HashSet<Integer> set = new HashSet<>();\n\n    for (int num : nums) {\n        set.add(num);\n    }\n\n    for (int num : nums) {\n        if (set.contains(num)) {\n            set.remove(num);\n            \n            int count = 1, start = num + 1;\n            while (set.contains(start)) {\n                set.remove(start++);\n                count++;\n            }\n\n            start = num - 1;\n            while (set.contains(start)) {\n                set.remove(start--);\n                count++;\n            }\n\n            longestSequence = Math.max(count, longestSequence);\n        }\n    }\n\n    return longestSequence;\n}","topicId":29},{"id":235,"position":1,"title":"Linked List Cycle","difficulty":1,"link":"https://leetcode.com/problems/linked-list-cycle/","hint":"NA","notes":"Revision Dates: 18/12/2023\nLast Revision Notes: Solved","solution":"public boolean hasCycle(ListNode head) {\n    ListNode slow, fast;\n\n    slow = fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (fast == slow) return true;\n    }\n\n    return false;\n}","topicId":30},{"id":236,"position":2,"title":"Add Two Numbers","difficulty":2,"link":"https://leetcode.com/problems/add-two-numbers/","hint":"Perform dfs to add nodes.","notes":"Revision Dates: 18/12/2023\nLast Revision Notes: Solved","solution":"public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    return dfs(l1, l2, 0);\n}\n\nListNode dfs(ListNode l1, ListNode l2, int carry){\n    if(l1 == null && l2 == null) {\n        return carry > 0 ? new ListNode(carry) : null;\n    }\n\n    int sum = carry;\n    if(l1 != null){\n        sum += l1.val;\n        l1 = l1.next;\n    }\n\n    if(l2 != null){\n        sum += l2.val;\n        l2 = l2.next;\n    }\n\n    ListNode tail = dfs(l1, l2, sum / 10);\n    ListNode head = new ListNode(sum % 10);\n    head.next = tail;\n\n    return head;\n}","topicId":30},{"id":237,"position":3,"title":"Merge Two Sorted Lists","difficulty":1,"link":"https://leetcode.com/problems/merge-two-sorted-lists/","hint":"Simplify if conditions","notes":"Revision Dates: 18/12/2023\nLast Revision Notes: Solved","solution":"public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n    if (list1 == null && list2 == null) return null;\n\n    ListNode head;\n    if (list2 == null || list1 != null && list1.val < list2.val) {\n        head = new ListNode(list1.val);\n        list1 = list1.next;\n    } else {\n        head = new ListNode(list2.val);\n        list2 = list2.next;\n    }\n\n    head.next = mergeTwoLists(list1, list2);\n    return head;\n}","topicId":30},{"id":238,"position":4,"title":"Copy List with Random Pointer","difficulty":2,"link":"https://leetcode.com/problems/copy-list-with-random-pointer/\nhttps://www.youtube.com/watch?v=VNf6VynfpdM","hint":"Algo:\n* Iteration1: insert copy node just after the original node.\n* Iteration2: copy the random pointer. (copy.random = original.random.next)\n* Iteration3: revert the original linked list and extract the copyied list.","notes":"Revision Dates: 18/12/2023\nLast Revision Notes: Not able to solve in S:O(1).","solution":"public Node copyRandomList(Node head) {\n    if (head == null) return null;\n    Node curr = head, copyHead;\n    //inserting copy node just after the original node\n    while (curr != null) {\n        Node next = curr.next;\n        Node copy = new Node(curr.val);\n        curr.next = copy;\n        copy.next = next;\n        curr = next;\n    }\n    //copying random pointer for copy nodes\n    curr = head;\n    while (curr != null) {\n        Node copy = curr.next;\n        if (curr.random != null) {\n            copy.random = curr.random.next;\n        }\n        curr = copy.next;\n    }\n    //reverting the original linked list and extracting copied list\n    copyHead = head.next;\n    curr = head;\n    while (curr != null) {\n        Node copy = curr.next;\n        curr.next = copy.next;\n        if (copy.next != null) {\n            copy.next = copy.next.next;\n        }\n        curr = curr.next;\n    }\n\n    return copyHead;\n}","topicId":30},{"id":369,"position":5,"title":"Reverse Linked List II","difficulty":2,"link":"https://leetcode.com/problems/reverse-linked-list-ii/","hint":"Before solving think about which node will be:\n* left part's tail.\n* reversed part's head.\n* reversed part's tail.\n* right part's head.","notes":"Revision Dates: 19/12/2023\nLast Revision Notes: Solved","solution":"public ListNode reverseBetween(ListNode head, int left, int right) {\n    ListNode leftTail, revHead, revTail, rightHead;\n\n    leftTail = null; // left part's tail will be node at left - 1 index \n    revTail = head;  // reversed part's tail will be node at left index.\n    for (int i = 1; i < left; i++) {\n        leftTail = revTail;\n        revTail = revTail.next;\n    }\n\n    rightHead = revTail; // right part tail will be node at right + 1 index.\n    revHead = null; // reversed part's head will be the node at right index.\n    for (int i = left; i <= right; i++) {\n        ListNode next = rightHead.next;\n        rightHead.next = revHead;\n        revHead = rightHead;\n        rightHead = next;\n    }\n\n    revTail.next = rightHead;\n    if (leftTail == null) head = revHead;\n    else leftTail.next = revHead;\n\n    return head;\n}","topicId":30},{"id":370,"position":6,"title":"Reverse Nodes in k-Group","difficulty":3,"link":"https://leetcode.com/problems/reverse-nodes-in-k-group/\nhttps://www.youtube.com/watch?v=1UOPsfP85V4","hint":"* Get the kthNode.\n* If the kthNode is null that means we don't need to reverse, return the head.\n* Make recursive call to reverse next group.\n* Reverse the current group.\n* Attach the head.next (head is current group's tail) to nextGroup.\n* return the prev (prev is currentGroup head)","notes":"Revision Dates: 19/12/2023\nLast Revision Notes: Solved","solution":"public ListNode reverseKGroup(ListNode head, int k) {\n    ListNode kthNode = getKthNode(head, k);\n    if (kthNode == null) return head;\n\n    ListNode nextGroup = reverseKGroup(kthNode.next, k);\n\n    ListNode prev = null, curr = head;\n    while (k > 0) {\n        ListNode next = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = next;\n        k--;\n    }\n\n    head.next = nextGroup;\n    return prev;\n}\n\nListNode getKthNode(ListNode node, int k) {\n    while (k > 1 && node != null) {\n        node = node.next;\n        k--;\n    }\n    return node;\n}","topicId":30},{"id":371,"position":7,"title":"Remove Nth Node From End of List","difficulty":2,"link":"https://leetcode.com/problems/remove-nth-node-from-end-of-list/","hint":"* Create one dummy node and attach it just before the head.\n* Assign slow and fast to dummy node.\n* Move fast pointer N times.\n* Again move fast and slow till fast.next != null.\n* Delete the node at slow.next by assigning slow.next = slow.next.next.\n* return dummy.next\n","notes":"Revision Dates: 19/12/2023\nLast Revision Notes: Solved","solution":"public ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode dummy, slow, fast;\n    dummy = new ListNode(0, head);\n    slow = fast = dummy;\n\n    while (n > 0) {\n        fast = fast.next;\n        n--;\n    }\n\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n\n    slow.next = slow.next.next;\n\n    return dummy.next;\n}","topicId":30},{"id":372,"position":8,"title":"Remove Duplicates from Sorted List II","difficulty":2,"link":"https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/","hint":"Recursive approach:\n* Base case : head is empty or head is the last node return head.\n* if the head and head next value is unique then append the result of deleteDuplicates(head.next).\n* else remove all the duplicates and return result of deleteDuplicates(curr).\n\n\n","notes":"Revision Dates: 19/12/2023\nLast Revision Notes: Solved","solution":"public ListNode deleteDuplicates(ListNode head) {\n    if (head == null || head.next == null) {\n        return head;\n    } else if (head.val != head.next.val) {\n        head.next = deleteDuplicates(head.next);\n        return head;\n    } else {\n        ListNode curr = head;\n        while (curr != null && curr.val == head.val) {\n            curr = curr.next;\n        }\n        return deleteDuplicates(curr);\n    }\n}","topicId":30},{"id":374,"position":9,"title":"Rotate List","difficulty":2,"link":"https://leetcode.com/problems/rotate-list/","hint":"Detach after n - k items.","notes":"Revision Dates: 20/12/2023\nLast Revision Notes: Solved.","solution":"public ListNode rotateRight(ListNode head, int k) {\n    if (head == null || head.next == null || k == 0) return head;\n\n    int size = 1;\n    ListNode tail = head;\n    while (tail != null && tail.next != null) {\n        tail = tail.next;\n        size++;\n    }\n\n    k = k % size;\n    if (k == 0) return head;\n\n    ListNode curr = head;\n    for (int i = 1; i < size - k; i++) {\n        curr = curr.next;\n    }\n\n    tail.next = head;\n    head = curr.next;\n    curr.next = null;\n\n    return head;\n}","topicId":30},{"id":375,"position":10,"title":"Partition List","difficulty":2,"link":"https://leetcode.com/problems/partition-list/","hint":"Use dummy pointer.","notes":"Revision Dates: 20/12/2023\nLast Revision Notes: Solved","solution":"public ListNode partition(ListNode head, int x) {\n    ListNode head1 = new ListNode(0), tail1 = head1;\n    ListNode head2 = new ListNode(0), tail2 = head2;\n\n    while (head != null) {\n        if (head.val < x) {\n            tail1.next = tail1 = head;\n        } else {\n            tail2.next = tail2 = head;\n        }\n        head = head.next;\n    }\n\n    head1 = head1.next;\n    head2 = head2.next;\n    tail1.next = head2;\n    tail2.next = null;\n\n    if (head1 == null) return head2;\n    else return head1;\n}","topicId":30},{"id":376,"position":11,"title":"LRU Cache","difficulty":2,"link":"https://leetcode.com/problems/lru-cache/","hint":"Use double linked list with two values key and val.\n* get operation -> remove the node if exist and add to last.\n* put operation:\n** if exist -> update the value, remove the node and add to last.\n** if size == capacity -> remove the head.\n** else add to last.","notes":"Revision Dates: 20/12/2023\nLast Revision Notes: Solved","solution":"class LRUCache {\n    int capacity, size;\n    Node[] map;\n    Node head, tail;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.size = 0;\n        this.map = new Node[10001];\n    }\n\n    public int get(int key) {\n        if (map[key] != null) {\n            Node node = map[key];\n            removeNode(node);\n            addLast(node);\n            return node.val;\n        } else {\n            return -1;\n        }\n    }\n\n    public void put(int key, int value) {\n        if (get(key) != -1) {\n            map[key].val = value;\n            return;\n        }\n        \n        if (size == capacity) removeNode(head);\n        addLast(new Node(key, value));\n    }\n\n    void addLast(Node node) {\n        node.next = null;\n        if (size == 0) {\n            head = tail = node;\n        } else {\n            node.prev = tail;\n            tail.next = tail = node;\n        }\n        map[node.key] = node;\n        size++;\n    }\n\n    void removeNode(Node node) {\n        if (size == 1) {\n            head = tail = null;\n        } else {\n            if (node == head) {\n                head = head.next;\n                head.prev = null;\n            } else if (node == tail) {\n                tail = tail.prev;\n                tail.next = null;\n            } else {\n                node.prev.next = node.next;\n                node.next.prev = node.prev;\n            }\n        }\n        map[node.key] = null;\n        size--;\n    }\n}\n\nclass Node {\n    int key, val;\n    Node prev, next;\n\n    Node(int key, int val) {\n        this.key = key;\n        this.val = val;\n    }\n}","topicId":30},{"id":377,"position":1,"title":"Summary Ranges","difficulty":1,"link":"https://leetcode.com/problems/summary-ranges/","hint":"NA","notes":"Revision Dates: 20/12/2023\nLast Revision Notes: Solved","solution":"public List<String> summaryRanges(int[] nums) {\n    List<String> ranges = new ArrayList<>();\n    int n = nums.length, rangeStart;\n\n    if (n <= 1) {\n        if (n == 0) return ranges;\n        addRangeToList(nums[0], nums[0], ranges);\n        return ranges;\n    }\n\n    rangeStart = nums[0];\n    for (int i = 1; i < n; i++) {\n        if (nums[i] - nums[i - 1] != 1) {\n            addRangeToList(rangeStart, nums[i - 1], ranges);\n            rangeStart = nums[i];\n        }\n    }\n\n    if (nums[n - 1] - nums[n - 2] != 1) {\n        addRangeToList(nums[n - 1], nums[n - 1], ranges);\n    } else {\n        addRangeToList(rangeStart, nums[n - 1], ranges);\n    }\n    \n    return ranges;\n}\n\nvoid addRangeToList(int a, int b, List<String> ranges) {\n    if (a == b) {\n        ranges.add(String.valueOf(a));\n    } else {\n        ranges.add(a + \"->\" + b);\n    }\n}","topicId":47},{"id":378,"position":2,"title":"Merge Intervals","difficulty":2,"link":"https://leetcode.com/problems/merge-intervals/","hint":"Sort the array by starting range then merge the intervals.","notes":"Revision Dates: 20/12/2023\nLast Revision Notes: Solved.","solution":"public int[][] merge(int[][] intervals) {\n    int n = intervals.length, idx = 0;\n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n\n    int[] prev = intervals[0];\n    for (int i = 1; i < intervals.length; i++) {\n        int[] curr = intervals[i];\n        if (curr[0] >= prev[0] && curr[0] <= prev[1]) {\n            prev[1] = Math.max(prev[1], curr[1]);\n        } else {\n            intervals[idx++] = prev;\n            prev = curr;\n        }\n    }\n    intervals[idx++] = prev;\n    \n    int[][] result = new int[idx][2];\n    System.arraycopy(intervals, 0, result, 0, idx);\n\n    return result;\n}","topicId":47},{"id":379,"position":3,"title":"Insert Interval","difficulty":2,"link":"https://leetcode.com/problems/insert-interval/","hint":"Check which interval will be added first.","notes":"Revision Dates: 20/12/2023\nLast Revision Notes: Solved","solution":"public int[][] insert(int[][] intervals, int[] newInterval) {\n    ArrayList<int[]> result = new ArrayList<>();\n\n    int[] prev = newInterval;\n    for (int[] curr : intervals) {\n        if (prev[1] < curr[0]) {\n            //prev will be added\n            result.add(prev);\n            prev = curr;\n        } else if (curr[1] < prev[0]) {\n            // curr will be added\n            result.add(curr);\n        } else {\n            // both will be merged\n            prev[0] = Math.min(prev[0], curr[0]);\n            prev[1] = Math.max(prev[1], curr[1]);\n        }\n    }\n\n    result.add(prev);\n    return result.toArray(new int[result.size()][]);\n}","topicId":47},{"id":380,"position":4,"title":"Minimum Number of Arrows to Burst Balloons","difficulty":2,"link":"https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/","hint":"Greedy Algo:\n* Sort the points according to endPoint.\n* Place the arrow at the end point of baloon.\n* keep brusting the balloon till its start point is less or equal to xEnd.\n* else increase the arrow and update the xEnd.","notes":"Revision Dates: 22/12/2023\nLast Revision Notes: Solved","solution":"public int findMinArrowShots(int[][] points) {\n    Arrays.sort(points, (a, b) -> a[1] < b[1] ? -1 : 1);\n\n    int arrows = 1, xEnd = points[0][1];\n    for (int[] point : points) {\n        if (point[0] > xEnd) {\n            arrows++;\n            xEnd = point[1];\n        }\n    }\n\n    return arrows;\n}","topicId":47},{"id":381,"position":1,"title":"Valid Parentheses","difficulty":1,"link":"https://leetcode.com/problems/valid-parentheses/","hint":"NA","notes":"Revision Dates: 22/12/2023\nLast Revision Notes: Solved","solution":"public boolean isValid(String s) {\n    Stack<Character> stack = new Stack<>();\n    \n    for (char c : s.toCharArray()) {\n        if (c == ')') {\n            if (stack.isEmpty() || stack.peek() != '(') return false;\n            stack.pop();\n        } else if (c == ']') {\n            if (stack.isEmpty() || stack.peek() != '[') return false;\n            stack.pop();\n        } else if (c == '}') {\n            if (stack.isEmpty() || stack.peek() != '{') return false;\n            stack.pop();\n        } else {\n            stack.push(c);\n        }\n    }\n\n    return stack.isEmpty();\n}","topicId":48},{"id":382,"position":2,"title":"Simplify Path","difficulty":2,"link":"https://leetcode.com/problems/simplify-path/","hint":"Algo:\n* Split the string by \"/\".\n* ignore empty string and single dot.\n* if we see double dot then pop.\n* else add it to stack.","notes":"Revision Dates: 22/12/2023\nLast Revision Notes: Solved","solution":"public String simplifyPath(String path) {\n    LinkedList<String> deque = new LinkedList<>();\n    for (String str : path.split(\"/\")) {\n        if (str.isEmpty() || str.equals(\".\")) continue;\n\n        if (str.equals(\"..\")) {\n            if (!deque.isEmpty()) deque.removeLast();\n        } else {\n            deque.addLast(str);\n        }\n    }\n\n    StringBuilder simplifiedPath = new StringBuilder();\n    for (String str : deque) {\n        simplifiedPath.append(\"/\");\n        simplifiedPath.append(str);\n    }\n\n    return simplifiedPath.length() == 0 ? \"/\" : simplifiedPath.toString();\n}","topicId":48},{"id":383,"position":3,"title":"Min Stack","difficulty":2,"link":"https://leetcode.com/problems/min-stack/","hint":"Use pair class to keep track of min and val.","notes":"Revision Dates: 22/12/2023\nLast Revision Notes: Solved","solution":"class MinStack {\n    \n    class Pair {\n        int min, val;\n\n        Pair(int min, int val) {\n            this.min = min;\n            this.val = val;\n        }\n    }\n\n    Stack<Pair> stack;\n    public MinStack() {\n        stack = new Stack<>();\n    }\n\n    public void push(int val) {\n        int min = stack.isEmpty() ? val : Math.min(stack.peek().min, val);\n        stack.push(new Pair(min, val));\n    }\n\n    public void pop() {\n        stack.pop();\n    }\n\n    public int top() {\n        return stack.peek().val;\n    }\n\n    public int getMin() {\n        return stack.peek().min;\n    }\n}","topicId":48},{"id":384,"position":4,"title":"Evaluate Reverse Polish Notation","difficulty":2,"link":"https://leetcode.com/problems/evaluate-reverse-polish-notation","hint":"Keep adding the numbers to the stack.\nIf we see any operator then pop two numbers and calculate result and add the result to the stack.","notes":"Revision Dates: 22/12/2023\nLast Revision Notes: Solved","solution":"public int evalRPN(String[] tokens) {\n    Stack<Integer> stack = new Stack<>();\n\n    for (String token : tokens) {\n        if (Character.isDigit(token.charAt(token.length() - 1))) {\n            stack.push(Integer.valueOf(token));\n        } else {\n            stack.push(calculate(stack.pop(), stack.pop(), token));\n        }\n    }\n\n    return stack.pop();\n}\n\nint calculate(int b, int a, String operator) {\n    switch (operator) {\n        case \"+\":\n            return a + b;\n        case \"-\":\n            return a - b;\n        case \"*\":\n            return a * b;\n        default:\n            return a / b;\n    }\n}","topicId":48},{"id":385,"position":5,"title":"Basic Calculator","difficulty":3,"link":"https://leetcode.com/problems/basic-calculator/","hint":"Use recursion.\nAlso:\n* Start with sign = 1, result and value = 0;\n* if c == digit, find the full number.\n* if c == '+' or '-', update the value with previous sign and add the value to result. Then update the sign -1/1.\n* if c == '(' - call recursive function for i + 1 and store in value.\n* if c == ')' or idx == n, return the result + sign + value.","notes":"Revision Dates: 23/12/2023\nLast Revision Notes: Not able to solve","solution":"public int calculate(String s) {\n    int[] idx = { 0 };\n    return calculate(s, idx);\n}\n\npublic int calculate(String s, int[] idx) {\n    int result = 0, value = 0, sign = 1;\n\n    while (idx[0] < s.length()) {\n        char c = s.charAt(idx[0]);\n\n        if (Character.isDigit(c)) {\n            value *= 10;\n            value += c - '0';\n        } else if (c == '+' || c == '-') {\n            value *= sign;\n            result += value;\n\n            value = 0;\n            sign = c == '-' ? -1 : 1;\n        } else if (c == '(') {\n            idx[0]++;\n            value = calculate(s, idx);\n        } else if (c == ')') {\n            return result + sign * value;\n        }\n        idx[0]++;\n    }\n    return result + sign * value;\n}","topicId":48},{"id":386,"position":1,"title":"Implement Trie (Prefix Tree)","difficulty":2,"link":"https://leetcode.com/problems/implement-trie-prefix-tree/","hint":"Used recursion for solution.\nNode structure: \nNode {\n  boolean isWord;\n  Node letter[26];\n}","notes":"Revision Dates: 23/12/2023\nLast Revision Notes: Solved","solution":"class Trie {\n    Node root;\n\n    public Trie() {\n        root = new Node();\n    }\n\n    public void insert(String word) {\n        root.insert(word, 0);\n    }\n\n    public boolean search(String word) {\n        return root.search(word, 0);\n    }\n\n    public boolean startsWith(String prefix) {\n        return root.startsWith(prefix, 0);\n    }\n}\n\nclass Node {\n    boolean isWord;\n    Node[] letter;\n\n    public Node() {\n        isWord = false;\n        letter = new Node[26];\n    }\n\n    void insert(String s, int idx) {\n        if (idx == s.length()) {\n            isWord = true;\n            return;\n        }\n\n        int i = s.charAt(idx) - 'a';\n        if (letter[i] == null) {\n            letter[i] = new Node();\n        }\n\n        letter[i].insert(s, idx + 1);\n    }\n\n    boolean search(String s, int idx) {\n        if (idx == s.length()) {\n            return isWord;\n        }\n\n        int i = s.charAt(idx) - 'a';\n        if (letter[i] == null) {\n            return false;\n        } else {\n            return letter[i].search(s, idx + 1);\n        }\n    }\n\n    boolean startsWith(String s, int idx) {\n        if (idx == s.length()) {\n            return true;\n        }\n\n        int i = s.charAt(idx) - 'a';\n        if (letter[i] == null) {\n            return false;\n        } else {\n            return letter[i].startsWith(s, idx + 1);\n        }\n    }\n}","topicId":49},{"id":387,"position":2,"title":"Design Add and Search Words Data Structure","difficulty":2,"link":"https://leetcode.com/problems/design-add-and-search-words-data-structure/","hint":"If there is any dot, call search at every letter.","notes":"Revision Dates: 24/12/2023\nLast Revision Notes: Solved","solution":"class WordDictionary {\n    Node root;\n\n    public WordDictionary() {\n        root = new Node();\n    }\n\n    public void addWord(String word) {\n        root.add(word, 0);\n    }\n\n    public boolean search(String word) {\n        return root.search(word, 0);\n    }\n}\n\nclass Node {\n    boolean isWord;\n    Node[] letter;\n\n    Node() {\n        isWord = false;\n        letter = new Node[26];\n    }\n\n    void add(String s, int idx) {\n        if (idx == s.length()) {\n            isWord = true;\n            return;\n        }\n        int i = s.charAt(idx) - 'a';\n        if (letter[i] == null) {\n            letter[i] = new Node();\n        }\n        letter[i].add(s, idx + 1);\n    }\n\n    boolean search(String s, int idx) {\n        if (idx == s.length()) {\n            return isWord;\n        }\n\n        char c = s.charAt(idx);\n        if (c == '.') {\n            for (int i = 0; i < 26; i++) {\n                if (letter[i] != null && letter[i].search(s, idx + 1)) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            int i = c - 'a';\n            if (letter[i] == null) {\n                return false;\n            } else {\n                return letter[i].search(s, idx + 1);\n            }\n        }\n    }\n}","topicId":49},{"id":388,"position":3,"title":"Word Search II","difficulty":3,"link":"https://leetcode.com/problems/word-search-ii/\nhttps://youtube.com/watch?v=asbcE9mZz_U","hint":"Algo:\nStep 1: Build trie of all the word.\nStep 2: call dfs for every cell in board.\nStep 3: DFS logic:\n** if isWord then add the word to list.\n** if outOfBound || visited || letter not exist in trie then return.\n** call dfs in all the four directions.","notes":"Revision Dates: 24/12/2023\nLast Revision Notes: Got TLE","solution":"void dfs(int i, int j, Node node, char[][] board, List<String> list) {\n    if (node.word != null) {\n        list.add(node.word);\n        node.word = null;\n    }\n\n    if (i < 0 || j < 0 || i >= board.length || j >= board[0].length ||\n            board[i][j] == 0 || node.children[board[i][j] - 'a'] == null) {\n        return;\n    }\n\n    char charAtIJ = board[i][j];\n    Node child = node.children[charAtIJ - 'a'];\n    board[i][j] = 0; // visiting\n    dfs(i + 1, j, child, board, list);\n    dfs(i - 1, j, child, board, list);\n    dfs(i, j + 1, child, board, list);\n    dfs(i, j - 1, child, board, list);\n    board[i][j] = charAtIJ; // un-visiting\n}\n\npublic List<String> findWords(char[][] board, String[] words) {\n    Node trieRootNode = new Node();\n    for (String word : words) {\n        trieRootNode.insertWord(word, 0);\n    }\n\n    LinkedList<String> list = new LinkedList<>();\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[0].length; j++) {\n            dfs(i, j, trieRootNode, board, list);\n        }\n    }\n    return list;\n}\n\nclass Node {\n    Node[] children;\n    String word;\n\n    Node() {\n        children = new Node[26];\n        word = null;\n    }\n\n    void insertWord(String word, int idx) {\n        if (idx == word.length()) {\n            this.word = word;\n            return;\n        }\n        int i = word.charAt(idx) - 'a';\n        if (children[i] == null) {\n            children[i] = new Node();\n        }\n        children[i].insertWord(word, idx + 1);\n    }\n}","topicId":49},{"id":389,"position":1,"title":"Convert Sorted Array to Binary Search Tree","difficulty":1,"link":"https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/","hint":"Take:\n* mid as root\n* start to mid - 1 as left\n* mid + 1 to end as right","notes":"Revision Dates: 24/12/2023\nLast Revision Notes: Solved","solution":"public TreeNode sortedArrayToBST(int[] nums) {\n    return helper(nums, 0, nums.length - 1);\n}\n\nTreeNode helper(int[] nums, int start, int end) {\n    if (start > end) return null;\n\n    int mid = start + (end - start) / 2;\n\n    TreeNode root = new TreeNode(nums[mid]);\n    root.left = helper(nums, start, mid - 1);\n    root.right = helper(nums, mid + 1, end);\n\n    return root;\n}","topicId":50},{"id":390,"position":2,"title":"Sort List","difficulty":2,"link":"https://leetcode.com/problems/sort-list/","hint":"NA","notes":"Revision Dates: 25/12/2023\nLast Revision Notes: Used mergeSort.","solution":"public ListNode sortList(ListNode head) {\n    if (head == null || head.next == null) return head;\n\n    ListNode slow, fast, prev;\n    slow = fast = prev = head;\n    while (fast != null && fast.next != null) {\n        prev = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    ListNode right = sortList(prev.next);\n    prev.next = null;\n    ListNode left = sortList(head);\n\n    return merge(left, right);\n}\n\nListNode merge(ListNode left, ListNode right) {\n    ListNode dummyNode = new ListNode(0), curr = dummyNode;\n    while (left != null && right != null) {\n        if (left.val < right.val) {\n            curr.next = left;\n            left = left.next;\n        } else {\n            curr.next = right;\n            right = right.next;\n        }\n        curr = curr.next;\n    }\n\n    curr.next = left == null ? right : left;\n\n    return dummyNode.next;\n}","topicId":50},{"id":391,"position":3,"title":"Construct Quad Tree","difficulty":2,"link":"https://leetcode.com/problems/construct-quad-tree/","hint":"visit all child first.\n* check if all child is leaf and values are equal then return the root.\n* else make root.isLeaf = false, attach all the child and return the root.","notes":"Revision Dates: 25/12/2023\nLast Revision Notes: Not able to solve without seeing the solution.","solution":"public Node construct(int[][] grid) {\n    return dfs(grid, 0, 0, grid.length);\n}\n\nNode dfs(int[][] grid, int x, int y, int n) {\n    Node root = new Node(grid[x][y] == 1, true);\n    if (n == 1) return root;\n    else n = n / 2;\n\n    Node tl = dfs(grid, x, y, n);\n    Node tr = dfs(grid, x, y + n, n);\n    Node bl = dfs(grid, x + n, y, n);\n    Node br = dfs(grid, x + n, y + n, n);\n\n    root.isLeaf = tl.isLeaf && tr.isLeaf && bl.isLeaf && br.isLeaf;\n    root.isLeaf = root.isLeaf && tl.val == tr.val && tr.val == bl.val && bl.val == br.val;\n\n    if (!root.isLeaf) {\n        root.topLeft = tl;\n        root.topRight = tr;\n        root.bottomLeft = bl;\n        root.bottomRight = br;\n    }\n\n    return root;\n}","topicId":50},{"id":392,"position":4,"title":"Merge k Sorted Lists","difficulty":3,"link":"https://leetcode.com/problems/merge-k-sorted-lists/\nhttps://www.youtube.com/watch?v=q5a5OiGbT6Q","hint":"Algo:\n* Merge first and second list.\n* Then third and fourth list.\n* contine till second last and last or for odd case. last and null.\n* decrease the size of array = (n + 1) / 2.\n* at last there will be only one list in array and that will be the merged list.\n","notes":"Revision Dates: 25/12/2023\nLast Revision Notes: Solved.","solution":"public ListNode mergeKLists(ListNode[] lists) {\n    if (lists.length == 0) return null;\n    return mergeKLists(lists, lists.length);\n}\n\npublic ListNode mergeKLists(ListNode[] lists, int n) {\n    if (n == 1) return lists[0];\n\n    int idx = 0;\n    for (int i = 0; i < n; i += 2) {\n        ListNode list1 = lists[i];\n        ListNode list2 = i + 1 < n ? lists[i + 1] : null;\n        //using input array instead of creating new one.\n        lists[idx++] = mergeTwoLists(list1, list2);\n    }\n\n    return mergeKLists(lists, (n + 1) / 2);\n}\n\npublic ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n    if (list2 == null) return list1;\n    if (list1 == null) return list2;\n\n    ListNode head = null;\n    if (list1.val < list2.val) {\n        head = list1;\n        head.next = mergeTwoLists(list1.next, list2);\n    } else {\n        head = list2;\n        head.next = mergeTwoLists(list1, list2.next);\n    }\n    return head;\n}","topicId":50},{"id":393,"position":1,"title":"Maximum Subarray","difficulty":2,"link":"https://leetcode.com/problems/maximum-subarray/","hint":"Check if currSum + nums[i] < nums[i] then only update the currSum = nums[i].\nelse add nums[i] to currSum.","notes":"Revision Dates: 25/12/2023\nLast Revision Notes: SOlved","solution":"public int maxSubArray(int[] nums) {\n    int maxSum, currSum, n = nums.length;\n    maxSum = currSum = nums[0];\n    \n    for (int i = 1; i < n; i++) {\n        if (currSum + nums[i] < nums[i]) {\n            currSum = nums[i];\n        } else {\n            currSum += nums[i];\n        }\n        maxSum = Math.max(maxSum, currSum);\n    }\n\n    return maxSum;\n}","topicId":51},{"id":394,"position":2,"title":"Maximum Sum Circular Subarray","difficulty":2,"link":"https://leetcode.com/problems/maximum-sum-circular-subarray/\nhttps://www.youtube.com/watch?v=fxT9KjakYPM","hint":"In circular array there may be three cases:\n1. Answer exist in normal array : use Kardane's Algorithm.\n2. If all the elements in the array is negative then maxSum will be single digit and that will be globalMax.\n3. Answer exist in circular array : we can use the formula x + y = z\n --- where x is maxSum, y is minSum and z is totalSum, so maxSum will be totalSum - minSum.\n\n","notes":"Revision Dates: 26/12/2023\nLast Revision Notes: Not able to solve in O(N).","solution":"public int maxSubarraySumCircular(int[] nums) {\n    int globalMin, globalMax, min, max, total;\n    globalMin = globalMax = min = max = total = nums[0];\n\n    for (int i = 1; i < nums.length; i++) {\n        max = Math.max(max + nums[i], nums[i]);\n        globalMax = Math.max(max, globalMax);\n\n        min = Math.min(min + nums[i], nums[i]);\n        globalMin = Math.min(min, globalMin);\n\n        total += nums[i];\n    }\n\n    if (globalMax < 0) return globalMax;\n    else return Math.max(globalMax, total - globalMin);\n}","topicId":51},{"id":395,"position":1,"title":"Search Insert Position","difficulty":1,"link":"https://leetcode.com/problems/search-insert-position/","hint":"left will be the insertion point if not found.","notes":"Revision Dates: 26/12/2023\nLast Revision Notes: Not able to solve.","solution":"public int searchInsert(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] == target) return mid;\n        else if (nums[mid] > target) right = mid - 1;\n        else left = mid + 1;\n    }\n\n    return left;\n}","topicId":52},{"id":396,"position":2,"title":"Search a 2D Matrix","difficulty":2,"link":"https://leetcode.com/problems/search-a-2d-matrix/","hint":"Use formula for calculating mid: row = mid / n , col = min % n of m x n matrix.","notes":"Revision Dates: 26/12/2023\nLast Revision Notes: Solved.","solution":"public boolean searchMatrix(int[][] matrix, int target) {\n    int m = matrix.length, n = matrix[0].length, left = 0, right = m * n - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        int val = matrix[mid / n][mid % n];\n\n        if (val == target) return true;\n        else if (val > target) right = mid - 1;\n        else left = mid + 1;\n    }\n\n    return false;\n}","topicId":52},{"id":398,"position":3,"title":"Find Peak Element","difficulty":2,"link":"https://leetcode.com/problems/find-peak-element/\nhttps://www.youtube.com/watch?v=cXxmbemS6XM","hint":"Algo:\n* given than nums[-1] = nums[n] = -infinity.\n* According to above assumption, we can easily say that peak element must exists.\n* Now check if the first element (nums[0]) is peak element return 0.\n* if last element is peak element (nums[n - 1]) is peak element then return n - 1.\n* start binarySearch from left = 1 and right = n - 2. Since first and last element is already checked.\n* if mid is the peak element, return peak.\n* if mid is on the increasing slope then peak must be in right part.\n* if mid is on the decreasing slope then peak must be in the left part.\n* if mid is on the negative peak then peak will be on both side.\n\nNote: draw graph for intutuion.","notes":"Revision Dates: 26/12/2023\nLast Revision Notes: Not able to think about peak logic.","solution":"public int findPeakElement(int[] nums) {\n    int n = nums.length;\n    if (n == 1 || nums[n - 1] > nums[n - 2]) return n - 1; // last element is peak\n    if (nums[0] > nums[1]) return 0; // first element is peak\n\n    int left = 1, right = n - 2; // skipping first and last element\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {\n            return mid;\n        } else if (nums[mid] > nums[mid - 1]) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return -1;\n}","topicId":52},{"id":399,"position":4,"title":"Search in Rotated Sorted Array","difficulty":2,"link":"https://leetcode.com/problems/search-in-rotated-sorted-array/","hint":"Algo: (Modified Binary Search)\n* In rotated sorted array, we can always say that either left part is sorted or right part is sorted. (sorted means that part doesn't contains rotation)\n* check which part is sorted.\n* then check if the target lies in sorted part then go to that part else go to other part.","notes":"Revision Dates: 27/12/2023\nLast Revision Notes: Not able to think the main logic","solution":"public int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] >= nums[left]) {\n            // left part is sorted\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            // right part is sorted\n            if (target <= nums[right] && target > nums[mid]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}","topicId":52},{"id":400,"position":5,"title":"Find First and Last Position of Element in Sorted Array","difficulty":2,"link":"https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/","hint":"Algo: Modified Binary search\n* Check if mid == target then\n* * chek left if the element exist and check right if the element exist.\n* * add the occurence accordingly.\n* else follow the normal binary search","notes":"Revision Dates: 27/12/2023\nLast Revision Notes: Solved","solution":"public int[] searchRange(int[] nums, int target) {\n    return helper(nums, target, 0, nums.length - 1);\n}\n\nint[] helper(int[] nums, int target, int left, int right) {\n    if (left > right) {\n        return new int[]{-1, -1};\n    }\n\n    int mid = left + (right - left) / 2;\n\n    if (nums[mid] == target) {\n        int[] firstIdx = helper(nums, target, left, mid - 1);\n        int[] lastIdx = helper(nums, target, mid + 1, right);\n\n        int[] firstLastIdx = new int[2];\n        firstLastIdx[0] = firstIdx[0] == -1 ? mid : firstIdx[0];\n        firstLastIdx[1] = lastIdx[1] == -1 ? mid : lastIdx[1];\n        return firstLastIdx;\n    } else if (nums[mid] > target) {\n        return helper(nums, target, left, mid - 1);\n    } else {\n        return helper(nums, target, mid + 1, right);\n    }\n}","topicId":52},{"id":401,"position":6,"title":"Find Minimum in Rotated Sorted Array","difficulty":2,"link":"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\nhttps://www.youtube.com/watch?v=nhEMDKMB44g","hint":"Algo:\n** we know that in rotated sorted array there will be three cases.\n1. Either whole array is sorted (no rotation) then return the nums[left].\n2. Right part is sorted then set the right to mid (as mid is the smallest from right part).\n2. Left part is sorted then set the left to mid + 1 (as we have alread checked that left is > than right).\n\n","notes":"Revision Dates: 27/12/2023\nLast Revision Notes: Solved","solution":"public int findMin(int[] nums) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[left] <= nums[right]) {\n            // whole array is sorted\n            return nums[left];\n        } else if (nums[mid] <= nums[right]) {\n            // right part is sorted\n            right = mid; // answer might be mid.\n        } else {\n            // left part is sorted but right is smaller\n            left = mid + 1;\n        }\n    }\n    return -1;\n}","topicId":52},{"id":402,"position":7,"title":"Median of Two Sorted Arrays","difficulty":3,"link":"https://leetcode.com/problems/median-of-two-sorted-arrays/","hint":"Algo:\n* Perform binary search from left = 0 to right = mid. (mid = (m + n + 1) / 2 ).\n* here binary search range represents the no. of element taken from first array.\n* check if partition is done properly otherwise adjust the partition.\n* also verify that l1 and l2 are smaller or equal to r2 and r1.\n* if all the condition stisfies then return the ans based on (n + m) is even or odd.","notes":"Revision Dates: 27/12/2023\nLast Revision Notes: Solved","solution":"public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    int m = nums1.length, n = nums2.length, mid = (m + n + 1) / 2, left = 0, right = mid;\n    while (left <= right) {\n        int partition1 = left + (right - left) / 2;\n        int partition2 = mid - partition1;\n        \n        if (partition1 > m) {\n            right = partition1 - 1;\n            continue;\n        }\n        if (partition2 > n) {\n            left = partition1 + 1;\n            continue;\n        }\n        \n        int l1 = partition1 == 0 ? Integer.MIN_VALUE : nums1[partition1 - 1];\n        int l2 = partition2 == 0 ? Integer.MIN_VALUE : nums2[partition2 - 1];\n        int r1 = partition1 == m ? Integer.MAX_VALUE : nums1[partition1];\n        int r2 = partition2 == n ? Integer.MAX_VALUE : nums2[partition2];\n\n        if (l1 > r2) {\n            right = partition1 - 1;\n        } else if (l2 > r1) {\n            left = partition1 + 1;\n        } else {\n            if ((m + n) % 2 == 0) {\n                return (Math.max(l1, l2) + Math.min(r1, r2)) / 2.0;\n            } else {\n                return Math.max(l1, l2);\n            }\n        }\n    }\n    return 0.0;\n}","topicId":52},{"id":403,"position":1,"title":"Add Binary","difficulty":1,"link":"https://leetcode.com/problems/add-binary/","hint":"NA","notes":"Revision Dates: 27/12/2023\nLast Revision Notes: Solved","solution":"public String addBinary(String a, String b) {\n    int m = a.length() - 1, n = b.length() - 1, carry = 0;\n    StringBuilder sb = new StringBuilder();\n\n    while (m >= 0 || n >= 0) {\n        int sum = carry;\n        if (m >= 0) sum += a.charAt(m--) - 48;\n        if (n >= 0) sum += b.charAt(n--) - 48;\n\n        carry = sum / 2;\n        sb.append(sum % 2);\n    }\n\n    if (carry == 1) sb.append(1);\n    return sb.reverse().toString();\n}","topicId":53},{"id":404,"position":2,"title":"Reverse Bits","difficulty":1,"link":"https://leetcode.com/problems/reverse-bits/\nhttps://www.youtube.com/watch?v=TC7nCh1MZM8","hint":"Algo:\nTake mask = 1, means at right most bit there will be 1.\nTake reverse = 0, means every bit is 0.\n* Every itteration get the last bit of n by n & mask and right shift n by 1.\n* left shift reverse and add the last bit by or operation (reverse | bit).\n* at last return the reverse.","notes":"Revision Dates: 27/12/2023\nLast Revision Notes: Not able to think the logic.","solution":"public int reverseBits(int n) {\n    int reverse = 0, mask = 1;\n    for (int i = 0; i < 32; i++) {\n        reverse = reverse << 1;\n        \n        int bit = n & mask;\n        reverse = reverse | bit;\n        n = n >> 1;\n    }\n    return reverse;\n}","topicId":53},{"id":405,"position":3,"title":"Number of 1 Bits","difficulty":1,"link":"https://leetcode.com/problems/number-of-1-bits/","hint":"Algo:\nTake mask = 1, so that rightmost bit of mask will be 1.\nzin every iteration do the following:\n* get the rightmost bit of n using (n & mask) and add it to count. (we can add without checking as 0 will not increase the count).\n* right shift n by one. ","notes":"Revision Dates: 27/12/2023\nLast Revision Notes: Solved","solution":"public int hammingWeight(int n) {\n    int mask = 1, onBitCount = 0;\n    for (int i = 0; i < 32; i++) {\n        onBitCount += n & mask;\n        n >>= 1;\n    }\n    return onBitCount;\n}","topicId":53},{"id":406,"position":4,"title":"Single Number","difficulty":1,"link":"https://leetcode.com/problems/single-number/","hint":"XOR of same number will give 0.\nif number only one number is appeared single/odd times then after XOR of every number, it will contain the number with odd frequency.","notes":"Revision Dates: 27/12/2023\nLast Revision Notes: Solved","solution":"public int singleNumber(int[] nums) {\n    int xor = 0;\n    for (int num : nums) {\n        xor ^= num;\n    }\n    return xor;\n}","topicId":53},{"id":407,"position":5,"title":"Single Number II","difficulty":2,"link":"https://leetcode.com/problems/single-number-ii/\nhttps://www.youtube.com/watch?v=jO7uGdvGGC4","hint":"Algo: \n* count 1's of every bit.\n* then check if the bit is divisible by 3.\n* if count % 3 == 0, it means that bit of result should be off.\n* if count % 3 != 0, it means that bit of result should be 1.\n\nWe can always say that for any bit position if the singleNumber bit is '1' then it will not be divisible by 3.\ni.e. count % 3 != 0.","notes":"Revision Dates: 28/12/2023\nLast Revision Notes: Not able to think S:O(1) solution.","solution":"public int singleNumber(int[] nums) {\n    int result = 0, mask = 1;\n    for (int i = 0; i < 32; i++) {\n        int count = 0;\n        for (int num : nums) {\n            if ((num & mask) != 0) {\n                count++;\n            }\n        }\n\n        if ((count % 3) != 0) {\n            result |= mask;\n        }\n        mask <<= 1;\n    }\n    return result;\n}","topicId":53},{"id":408,"position":6,"title":"Bitwise AND of Numbers Range","difficulty":2,"link":"https://leetcode.com/problems/bitwise-and-of-numbers-range/\nhttps://www.youtube.com/watch?v=DYVu92_blCk","hint":"Logic : Right shift left and right till both are equal, also track the shift count.\n* Means start omitting unequal elements from left till both are equal.\n* Once both are equal then left shift the left or right by shiftCount. (Means all the unmatched will be replaced with zero).\n","notes":"Revision Dates: 28/12/2023\nLast Revision Notes: Not able to think about the optimal solution.","solution":"public int rangeBitwiseAnd(int left, int right) {\n    int shiftCount = 0;\n    while (right != left) {\n        left >>= 1;\n        right >>= 1;\n        shiftCount++;\n    }\n    return right << shiftCount;\n}","topicId":53},{"id":409,"position":1,"title":"Palindrome Number","difficulty":1,"link":"https://leetcode.com/problems/palindrome-number/","hint":"NA","notes":"Revision Dates: 28/12/2023\nLast Revision Notes: Solved.","solution":"public boolean isPalindrome(int x) {\n    int X = x, reversed = 0;\n    while (X > 0) {\n        reversed *= 10;\n        reversed += X % 10;\n        X /= 10;\n    }\n    return x == reversed;\n}","topicId":54},{"id":410,"position":2,"title":"Plus One","difficulty":1,"link":"https://leetcode.com/problems/plus-one/","hint":"NA","notes":"Revision Dates: 28/12/2023\nLast Revision Notes: Solved","solution":"public int[] plusOne(int[] digits) {\n    int n = digits.length, carry = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        int sum = digits[i] + carry;\n        carry = sum / 10;\n        digits[i] = sum % 10;\n\n        if (carry == 0) {\n            // no need to go forward\n            return digits;\n        }\n    }\n\n\n    int[] result = new int[n + 1];\n    result[0] = 1;\n    // no need to copy digits, as all are zeros.\n    return result;\n}","topicId":54},{"id":411,"position":3,"title":"Factorial Trailing Zeroes","difficulty":2,"link":"https://leetcode.com/problems/factorial-trailing-zeroes/","hint":"Factorization of five will give trailing zeros.","notes":"Revision Dates: 28/12/2023\nLast Revision Notes: Solved","solution":"public int trailingZeroes(int n) {\n    if (n < 5) return 0;\n    return n / 5 + trailingZeroes(n / 5);\n}","topicId":54},{"id":412,"position":4,"title":"Sqrt(x)","difficulty":1,"link":"https://leetcode.com/problems/sqrtx/","hint":"Use binary search for finding i such that i * i <= x.\nNote: for overflow optimization we can check i = (x / i) instead of (i * i) == x.","notes":"Revision Dates: 28/12/2023\nLast Revision Notes: Not able to write the optimized code.","solution":"public int mySqrt(int x) {\n    if (x < 2) return x;\n\n    int left = 1, right = x;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (mid == x / mid || mid < x / mid && (mid + 1) > x / (mid + 1)) {\n            // mid * mid == x || mid * mid < x && (mid + 1) * (mid + 1) > x\n            return mid;\n        } else if (mid > x / mid) {\n            // mid * mid > x\n            right = mid - 1;\n        } else {\n            // mid * mid < x\n            left = mid + 1;\n        }\n    }\n\n    return left;\n}","topicId":54},{"id":413,"position":5,"title":"Pow(x, n)","difficulty":2,"link":"https://leetcode.com/problems/powx-n/","hint":"Algo:\n* Check if n % 2 == 0.\n* then return pow(x * x, n / 2).\n* else return x * pow(x * x, n / 2).\n* for negative power inver the x.","notes":"Revision Dates: 28/12/2023\nLast Revision Notes: Solved","solution":"public double myPow(double x, int n) {\n    if (n == 0) {\n        return 1;\n    } else if (n < 0) {\n        double X = 1 / x;\n        int N = -(n / 2);\n        return n % 2 == 0 ? myPow(X * X, N) : X * myPow(X * X, N);\n    } else {\n        return n % 2 == 0 ? myPow(x * x, n / 2) : x * myPow(x * x, n / 2);\n    }\n}","topicId":54},{"id":414,"position":6,"title":"Max Points on a Line","difficulty":3,"link":"https://leetcode.com/problems/max-points-on-a-line/\nhttps://www.youtube.com/watch?v=Bb9lOXUOnFw","hint":"* Find the slope by formula : y2 - y1 / x2 - x1. if x2 - x1 == 0 then slope will be infinity.\n* update the frequency if the slope matches and update max.\n\n","notes":"Revision Dates: 29/12/2023\nLast Revision Notes: Not solved.","solution":"public int maxPoints(int[][] points) {\n    int n = points.length, max = 1;\n    HashMap<Double, Integer> slopeMap = new HashMap<>();\n    for (int[] p1 : points) {\n        for (int[] p2 : points) {\n            if (p1 == p2) continue;\n            Double slope = p1[0] == p2[0] ? Integer.MAX_VALUE :\n                    (double) (p2[1] - p1[1]) / (p2[0] - p1[0]);\n\n            int freq = slopeMap.getOrDefault(slope, 1) + 1;\n            slopeMap.put(slope, freq);\n            max = Math.max(freq, max);\n        }\n        slopeMap.clear();\n    }\n    return max;\n}","topicId":54},{"id":415,"position":1,"title":"Kth Largest Element in an Array","difficulty":2,"link":"https://leetcode.com/problems/kth-largest-element-in-an-array/","hint":"First fill k elements in priority queue.\nThen at every iteration check if current num is greater than peek() then remove() and add the num.","notes":"Revision Dates: 29/12/2023\nLast Revision Notes: Solved","solution":"public int findKthLargest(int[] nums, int k) {\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\n\n    for (int i = 0; i < k; i++) {\n        pq.add(nums[i]);\n    }\n\n    for (int i = k; i < nums.length; i++) {\n        if (pq.peek() < nums[i]) {\n            pq.remove();\n            pq.add(nums[i]);\n        }\n    }\n\n    return pq.peek();\n}","topicId":55},{"id":416,"position":2,"title":"IPO","difficulty":3,"link":"https://leetcode.com/problems/ipo/\nhttps://www.youtube.com/watch?v=1IUzNJ6TPEM","hint":"Algo: Two heap pattern.\n* First create a min-capital-heap.\n* Then just intitalize the max-profit-heap.\n\nthen run the loop for k times.\n* add all the profits to maxProfit which capital is less <= w.\n* add the maxProfit top to w.\n* break if max-profit-heap is empty.\n","notes":"Revision Dates: 29/12/2023\nLast Revision Notes: Not able to solve.","solution":"public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {\n    PriorityQueue<int[]> minCapital = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n    int n = capital.length;\n    for (int i = 0; i < n; i++) {\n        minCapital.offer(new int[]{capital[i], profits[i]});\n    }\n\n    PriorityQueue<Integer> maxProfit = new PriorityQueue<>((a, b) -> b - a);\n    while (k > 0) {\n        while (!minCapital.isEmpty() && minCapital.peek()[0] <= w) {\n            maxProfit.offer(minCapital.poll()[1]);\n        }\n        if (maxProfit.isEmpty())\n            break;\n        w += maxProfit.poll();\n        k--;\n    }\n    return w;\n}","topicId":55},{"id":417,"position":3,"title":"Find K Pairs with Smallest Sums","difficulty":2,"link":"https://leetcode.com/problems/find-k-pairs-with-smallest-sums/\nhttps://www.youtube.com/watch?v=GbYUDowP3wg","hint":"Algo:\nwe know that first pair will be at index {0, 0}\nsecond will be {1, 0} or {0, 1}\nsimilarly third will be {2, 0} or {1, 1} or {1, 1} (duplicate),  or {0, 2}.\nNote: we can obeserve that for every pair we are adding {i + 1, j} and {i, j + 1}.\n\nTo get rid of duplicates we can use HashSet or \nwe can put all {i + 1} in the queue so the we only have to put {i, j + 1} for the next pair.\nE.g. put all pairs {i, 0} where i < k && i < nums1.length. ","notes":"Revision Dates: 29/12/2023\nLast Revision Notes: Got TLE","solution":"public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\n    int m = nums1.length, n = nums2.length;\n    List<List<Integer>> pairs = new ArrayList<>(k);\n    // min-sum-heap, where arr[0] is nums1's index,\n    // arr[1] is nums2's index, arr[2] is sum of num1 + num2.\n    PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[2]));\n\n    for (int i = 0; i < m && i < k; i++) {\n        pq.offer(new int[]{i, 0, nums1[i] + nums2[0]});\n    }\n\n    while (k > 0 && !pq.isEmpty()) {\n        int[] top = pq.poll();\n\n        ArrayList<Integer> pair = new ArrayList<>(2);\n        pair.add(nums1[top[0]]);\n        pair.add(nums2[top[1]]);\n        pairs.add(pair);\n\n        if (top[1] + 1 < n) {\n            pq.offer(new int[]{top[0], top[1] + 1, nums1[top[0]] + nums2[top[1] + 1]});\n        }\n\n        k--;\n    }\n\n    return pairs;\n}","topicId":55},{"id":418,"position":4,"title":"Find Median from Data Stream","difficulty":3,"link":"https://leetcode.com/problems/find-median-from-data-stream/","hint":"Algo: Use two heap -> min and max\n\nAdd:\n* if min is empty or  num < minHeap.peek() insert in max\n* else insert in min.\n* then balance the heap if the size difference is more than 1.\n\nMedian:\n* return top of any heap whose size is greater else\n* return top of both heap divided by 2.","notes":"Revision Dates: 30/12/2023\nLast Revision Notes: Solved","solution":"class MedianFinder {\n    private PriorityQueue<Integer> minHeap, maxHeap;\n\n    public MedianFinder() {\n        minHeap = new PriorityQueue<>();\n        maxHeap = new PriorityQueue<>((a, b) -> b - a);\n    }\n\n    public void addNum(int num) {\n        if (minHeap.isEmpty() || num < minHeap.peek()) {\n            maxHeap.offer(num);\n        } else {\n            minHeap.offer(num);\n        }\n        balance();\n    }\n\n    public double findMedian() {\n        if (minHeap.size() > maxHeap.size()) {\n            return minHeap.peek();\n        } else if (maxHeap.size() > minHeap.size()) {\n            return maxHeap.peek();\n        } else {\n            return (minHeap.peek() + maxHeap.peek()) / 2.0;\n        }\n    }\n\n    private void balance() {\n        if (minHeap.size() - maxHeap.size() > 1) {\n            maxHeap.offer(minHeap.poll());\n        } else if (maxHeap.size() - minHeap.size() > 1) {\n            minHeap.offer(maxHeap.poll());\n        }\n    }\n}","topicId":55},{"id":1,"position":1,"title":"Leaders in an array","difficulty":1,"link":"https://practice.geeksforgeeks.org/problems/leaders-in-an-array-1587115620/1","hint":"Iterate over arr[] in reverse order. To avoid reversing the output you can use Stack.","notes":"Revision Dates: 01/08/22, 13/10/23\nLast Revision Notes: Solved without any issue.","solution":"static ArrayList<Integer> leaders(int arr[], int n) {\n    ArrayList<Integer> output = new ArrayList<>();\n    if (n <= 0) return output;\n\n    int leader = arr[n - 1];\n    output.add(leader);\n\n    for (int i = n - 2; i >= 0; i--) {\n        if (arr[i] >= leader) {\n            leader = arr[i];\n            output.add(leader);\n        }\n    }\n\n    Collections.reverse(output);\n    return output;\n}","topicId":2},{"id":2,"position":2,"title":"Equilibrium Point","difficulty":1,"link":"https://practice.geeksforgeeks.org/problems/equilibrium-point-1587115620/1","hint":"Calculate totalSum and keep track of currentSum.","notes":"Revision Dates: 01/08/22, 13/10/23 \nLast Revision Notes: Solved without any issue.","solution":"public static int equilibriumPoint(long arr[], int n) {\n    int notFound = -1;\n    if (n <= 0) return notFound;\n\n    long totalSum = 0;\n    for (int i = 0; i < n; i++) {\n        totalSum += arr[i];\n    }\n\n    long currentSum = 0;\n    for (int i = 0; i < n; i++) {\n        if (totalSum - currentSum - arr[i] == currentSum) {\n            return i + 1;\n        } else {\n            currentSum += arr[i];\n        }\n    }\n    \n    return notFound;\n}","topicId":2},{"id":3,"position":3,"title":"Sort Colors","difficulty":2,"link":"https://leetcode.com/problems/sort-colors/\nhttps://practice.geeksforgeeks.org/problems/sort-an-array-of-0s-1s-and-2s4231/1\nhttps://www.youtube.com/watch?v=tp8JIuCXBaU","hint":"Dutch National Flag Algorithm:\n1) Take 3 pointers: low = 0, mid = 0, high = n - 1.\n2) Assume everything till (low - 1) contains 0.\n3) Assume from (low) to (mid - 1) contains 1.\n4) Assume from (mid) to (high) unsorted.\n5) Assume after high contains 2.\n6) Use (mid) for decision making and run loop till (mid <= high)\n7) Dry run on copy and find the algorithm.","notes":"Revision Dates: 01/08/22, 16/10/23\nLast Revision Notes: Solved using 3 counter but not able to solve using 3 pointer (DNF Algo).","solution":"public void sortColors(int[] a) {\n    int low = 0, mid = 0, high = a.length - 1;\n\n    while (mid <= high) {\n        if (a[mid] == 0) swap(a, low++, mid++);\n        else if (a[mid] == 1) mid++;\n        else swap(a, mid, high--);\n    }\n}\n\nvoid swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}","topicId":2},{"id":4,"position":4,"title":"Reverse array in groups","difficulty":1,"link":"https://practice.geeksforgeeks.org/problems/reverse-array-in-groups0255/1","hint":"NA","notes":"Revision Dates: 01/08/22, 16/10/23\nLast Revision Notes: Solved using recursion and loop","solution":"void reverseInGroups(ArrayList<Integer> arr, int n, int k) {\n    int index = 0, left, right;\n\n    while (index < n) {\n        left = index;\n        right = index + k - 1;\n        index = right + 1;\n\n        if (right >= n) right = n - 1;\n\n        while (left < right) {\n            int temp = arr.get(left);\n            arr.set(left++, arr.get(right));\n            arr.set(right--, temp);\n        }\n    }\n}","topicId":2},{"id":5,"position":5,"title":"Convert array into Zig-Zag fashion","difficulty":1,"link":"https://practice.geeksforgeeks.org/problems/convert-array-into-zig-zag-fashion1638/1","hint":"Check if current index is even or odd then apply the swap logic accordingly.","notes":"Revision Dates: 01/08/22, 16/10/23\nLast Revision Notes: Solved without any issue.","solution":"public void zigZag(int a[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        if (i % 2 == 0 && a[i] > a[i + 1] || i % 2 != 0 && a[i] < a[i + 1]) {\n            int temp = a[i];\n            a[i] = a[i + 1];\n            a[i + 1] = temp;\n        }\n    }\n}","topicId":2},{"id":6,"position":6,"title":"Rearrange Array Alternately","difficulty":2,"link":"https://practice.geeksforgeeks.org/problems/-rearrange-array-alternately-1587115620/1\nhttps://www.youtube.com/watch?v=kQrezgskpho","hint":"* Formula used: Dividend = Quotient * Divisor + Remainder.\n* We can use this approach where we need to store initial and final value at same place.\n* Divisor || max || Maximum element of array + 1.\n* Quotient || Final value || Result you want to store at arr[i].\n* Remainder || Initial value || Initial value of arr[i].\n* Dividend || Combination of Initial and Final value || arr[i].\n* Or arr[i] = (Final value) * max + arr[i];\n* Hence ( Initial Value = arr[i] % max ) and ( Final Value = arr[i] / max ).\n\nNow for this question:\n1) Use two pointers: low = 0, high = n - 1;\n2) Find Divisor: max = arr[n -1] + 1;\n3) Iterate through the array.\n4) If current index is even then Final Value will be arr[high--] % max; (Taking % as we need initial value of high index)\n5) And for odd case Final Value will be arr[low++] % max; (Taking % as we need initial value of high index)\n6) Then Dividend => arr[i] = (Final Value) * max + arr[i];  \n7) At last divide each element by max so that only final value is present in the array.\n\n ","notes":"Revision Dates: 01/08/22, 17/10/23\nLast Revision Notes: Referred YT video for O(1) space complexity solution.","solution":"public static void rearrange(long arr[], int n) {\n    int low = 0, high = n - 1;\n    long max = arr[high] + 1;\n\n    for (int i = 0; i < n; i++) {\n        if (i % 2 == 0) {\n            arr[i] += (arr[high--] % max) * max;\n        } else {\n            arr[i] += (arr[low++] % max) * max;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        arr[i] /= max;\n    }\n}","topicId":2},{"id":7,"position":7,"title":"Missing number in array","difficulty":1,"link":"https://practice.geeksforgeeks.org/problems/missing-number-in-array1416/1","hint":"Two best approaches:\nXOR Operator : \n* It has certain properties that if a same number is XOR twice or multiple of 2 times then the result will be zero.\n* Eg: A ^ A = 0, A ^ A ^ A = A or A ^ B ^ A = B\n\nAdd and Subtract method:\n* Add index and subtract array element.\n* result += i - arr[i]\n* return result += n.\n\nAlso Cyclic Sort can be used.","notes":"Revision Dates: 01/08/22, 17/10/23\nLast Revision Notes: Solved without any issue. Will learn cyclic sort in future.","solution":"int missingNumber(int array[], int n) {\n    int missing = n;\n    for (int i = 1; i < n; i++) {\n        missing ^= array[i - 1];\n        missing ^= i;\n    }\n    return missing;\n}","topicId":2},{"id":8,"position":8,"title":"Check if two arrays are equal or not","difficulty":1,"link":"https://practice.geeksforgeeks.org/problems/check-if-two-arrays-are-equal-or-not3847/1","hint":"Use Hashmap to find the difference.","notes":"Revision Dates: 01/08/22, 20/10/23\nLast Revision Notes: Solved without any issue.","solution":"public static boolean check(long A[], long B[], int N) {\n    HashMap<Long, Integer> frequency = new HashMap<>();\n    for (int i = 0; i < N; i++) {\n        updateMap(A[i], frequency, false);\n        updateMap(B[i], frequency, true);\n    }\n    return frequency.size() == 0;\n}\n\nprivate static void updateMap(long key, HashMap<Long, Integer> frequency, boolean negative) {\n    int count = frequency.getOrDefault(key, 0);\n\n    if (negative) count--;\n    else count++;\n\n    if (count == 0) frequency.remove(key);\n    else frequency.put(key, count);\n}","topicId":2},{"id":9,"position":9,"title":"Maximum Subarray","difficulty":2,"link":"https://leetcode.com/problems/maximum-subarray/\nhttps://practice.geeksforgeeks.org/problems/kadanes-algorithm-1587115620/1","hint":"Kadane's Algorithm:\nThe main logic is that we will only reset the subarray left pointer or currentSum when the arr[i] is greater than the sum + arr[i].\nThis covers all the case and we will get the maximum contagious subarray sum","notes":"Revision Dates: 01/08/22, 20/10/23\nLast Revision Notes: Solved without any issue.","solution":"public int maxSubArray(int[] nums) {\n    int maxSum = Integer.MIN_VALUE, currentSum = 0, n = nums.length;\n\n    for (int i = 0; i < n; i++) {\n        currentSum += nums[i];\n        if (currentSum < nums[i]) {\n            currentSum = nums[i];\n        }\n        maxSum = Math.max(currentSum, maxSum);\n    }\n\n    return maxSum;\n}","topicId":2},{"id":10,"position":10,"title":"Subarray with given sum","difficulty":1,"link":"https://practice.geeksforgeeks.org/problems/subarray-with-given-sum-1587115621/1","hint":"Keep track of sum and left pointer.\nIf the sum is greater than the target then subtract the value at left pointer till the sum is greater than target.","notes":"Revision Dates: 01/08/22, 20/10/23\nLast Revision Notes: Solved without any issue.","solution":"static ArrayList<Integer> subarraySum(int[] arr, int n, int s) {\n    long sum = 0;\n    int left = 0;\n    ArrayList<Integer> result = new ArrayList<>();\n\n    for (int i = 0; i < n; i++) {\n        sum += arr[i];\n\n        while (sum > s && i > left) {\n            sum -= arr[left++];\n        }\n\n        if (sum == s) {\n            result.add(left + 1);\n            result.add(i + 1);\n            return result;\n        }\n    }\n\n    result.add(-1);\n    return result;\n}","topicId":2},{"id":11,"position":11,"title":"Trapping Rain Water","difficulty":3,"link":"https://leetcode.com/problems/trapping-rain-water/\nhttps://practice.geeksforgeeks.org/problems/trapping-rain-water-1587115621/1","hint":"* Take two pointer left and right.\n* Keep track of leftMaxHeight and rightMaxHeight and update accordingly.\n* Move pointer from the smaller maxHeight (leftMaxHeight or rightMaxHeight).\n* Try solving using pen and paper for this array {1, 1, 5, 2, 7, 6, 1, 4, 2, 3}.","notes":"Revision Dates: 01/08/22, 20/10/23\nLast Revision Notes: Solved without any issue.","solution":"public int trap(int[] height) {\n    int left, leftMaxHeight, right, rightMaxHeight, water;\n    left = leftMaxHeight = rightMaxHeight = water = 0;\n    right = height.length - 1;\n\n    while (left <= right) {\n        if (leftMaxHeight <= rightMaxHeight) {\n            leftMaxHeight = Math.max(height[left], leftMaxHeight);\n            water += leftMaxHeight - height[left++];\n        } else {\n            rightMaxHeight = Math.max(height[right], rightMaxHeight);\n            water += rightMaxHeight - height[right--];\n        }\n    }\n    return water;\n}","topicId":2},{"id":12,"position":12,"title":"Minimum Platforms","difficulty":2,"link":"https://practice.geeksforgeeks.org/problems/minimum-platforms-1587115620/1","hint":"* Sort both arrays individually.\n* Use one pointer for departure.\n* Iterate through the arrival array.\n* If arrival is greater than the current departure then decrease the platform and increase the departure pointer.","notes":"Revision Dates: 01/08/22, 20/10/23\nLast Revision Notes:  Forgot to sort arrival array.","solution":"int findPlatform(int arr[], int dep[], int n) {\n    Arrays.sort(arr);\n    Arrays.sort(dep);\n\n    int platform = 0;\n    int departure = 0;\n    for (int i = 0; i < n; i++) {\n        if (dep[departure] < arr[i]) {\n            departure++;\n            platform--;\n        }\n        platform++;\n    }\n\n    return platform;\n}","topicId":2},{"id":13,"position":13,"title":"Stock buy and sell","difficulty":2,"link":"https://practice.geeksforgeeks.org/problems/stock-buy-and-sell-1587115621/1","hint":"* Continue iterating through the array till the stock price is in increasing order or lastDay(n - 1).\n* If the yesterday's price is >= to the today's price or not in increasing order, assign the sellDay as yesterday.\n* If its lastDay assign the sellDay to today or yesterday whichever is higher because \n   we cannot differentiate that the IF condition holds true for Non-Increasing Order or lastDay.\n* Re-assign the buyDay to today.","notes":"Revision Dates: 01/08/22, 20/10/23\nLast Revision Notes:  Solved without any issue.","solution":"ArrayList<ArrayList<Integer>> stockBuySell(int A[], int n) {\n    ArrayList<ArrayList<Integer>> profits = new ArrayList<>();\n    \n    int buyDay = 0;\n    for (int today = 1; today < n; today++) {\n        if (A[today - 1] >= A[today] || today == n - 1) {\n            int sellDay = today - 1;\n            if (today == n - 1 && A[today] > A[today - 1]) {\n                sellDay = today;\n            }\n\n            if (A[sellDay] - A[buyDay] > 0) {\n                ArrayList<Integer> list = new ArrayList<>();\n                list.add(buyDay);\n                list.add(sellDay);\n                profits.add(list);\n            }\n            buyDay = today;\n        }\n    }\n    return profits;\n}","topicId":2},{"id":14,"position":14,"title":"Largest Number formed from an Array","difficulty":2,"link":"https://practice.geeksforgeeks.org/problems/largest-number-formed-from-an-array1117/1","hint":"* Use comparator with condition (a + b).compareTo(b + a) to verify which combination is greater.\n* Then join the sorted string in reverse.","notes":"Revision Dates: 01/08/22, 21/10/23\nLast Revision Notes:  Not able to think about compare (a + b) and (b + a).","solution":"String printLargest(String[] arr) {\n    Arrays.sort(arr, (a, b) -> {\n        return (a + b).compareTo(b + a);\n    });\n\n    StringBuffer largest = new StringBuffer();\n    for (int i = arr.length - 1; i >= 0; i--) {\n        largest.append(arr[i]);\n    }\n    return largest.toString();\n}","topicId":2},{"id":15,"position":15,"title":"Largest subarray with 0 sum","difficulty":2,"link":"https://practice.geeksforgeeks.org/problems/largest-subarray-with-0-sum/1\nhttps://www.youtube.com/watch?v=Bne92MpRieE&t=244s","hint":"* We will use prefix sum solution.\n* Logic: If we get the same sum for the second time, then we can say that sum after the first occurrence index and current index must be zero.\n* To store the sum and first occurrence index we will use HashMap.\n* Take HashMap and store (0, -1) initially, means sum = 0 found at -1 index.\n* Iterate through the array and adding the sum and check if sum exists or not\n* If exists update the maxLength else add in HashMap.\n","notes":"Revision Dates: 01/08/22, 26/10/23\nLast Revision Notes: Not able to think about prefix sum solution.","solution":"int maxLen(int arr[], int n) {\n    HashMap<Long, Integer> map = new HashMap<>();\n    map.put(0L, -1);\n    \n    int maxLength = 0;\n    long sum = 0L;\n    for (int i = 0; i < n; i++) {\n        sum += arr[i];\n        if (map.containsKey(sum)) {\n            maxLength = Math.max(maxLength, i - map.get(sum));\n        } else {\n            map.put(sum, i);\n        }\n    }\n    return maxLength;\n}","topicId":2},{"id":16,"position":16,"title":"Swapping pairs make sum equal","difficulty":2,"link":"https://practice.geeksforgeeks.org/problems/swapping-pairs-make-sum-equal4142/1","hint":"* Calculate the formula: sumA - A + B = sumB + A - B => sumA - sumB = 2(A - B) => (sumA - sumB)/2 = A - B\n* Store A[] elements in hashMap and calculate sumA and sumB;\n* Let's say target = (sumA - sumB) / 2 and if (sumA - sumB) % 2 != 0 then we can find solution.\n* Use formula A = target + B, to check if swapping numbers would make array equal. ","notes":"Revision Dates: 01/08/22, 26/10/23\nLast Revision Notes: Solved without any issue. Next time try solving in O(1) Space Complexity.","solution":"long findSwapValues(long A[], int n, long B[], int m) {\n    HashSet<Long> setA = new HashSet<>();\n    long sumA = 0, sumB = 0;\n    int i = 0, j = 0;\n\n    while (true) {\n        if (i < n) {\n            setA.add(A[i]);\n            sumA += A[i++];\n        }\n\n        if (j < m) {\n            sumB += B[j++];\n        }\n\n        if (i == n && j == m) break;\n    }\n\n    if ((sumA - sumB) % 2 != 0) return -1;\n    \n    long target = (sumA - sumB) / 2;\n    for (i = 0; i < m; i++) {\n        if (setA.contains(target + B[i])) {\n            return 1;\n        }\n    }\n\n    return -1;\n}","topicId":2},{"id":17,"position":6,"title":"Binary Search","difficulty":1,"link":"https://leetcode.com/problems/binary-search/","hint":"Try to implement iterative approach.","notes":"Revision Dates: 01/08/22, 27/10/23\nLast Revision Notes: Solved without any issue.","solution":"public int search(int[] nums, int target) {\n    int start = 0, end = nums.length - 1, mid = 0;\n    while (start <= end) {\n        mid = start + (end - start) / 2;\n        if (nums[mid] == target) return mid;\n        else if (nums[mid] > target) end = mid - 1;\n        else start = mid + 1;\n    }\n    return -1;\n}","topicId":3},{"id":18,"position":1,"title":"Quick Sort","difficulty":2,"link":"https://leetcode.com/problems/sort-an-array/\nhttps://practice.geeksforgeeks.org/problems/quick-sort/1","hint":"* The main logic behind the quick-sort is finding the pivot such that left side elements are <= PIVOT and right side elements are > PIVOT.\n\n\n","notes":"Revision Dates: 01/08/22, 29/10/23\nLast Revision Notes: Solved without any issue.","solution":"public int[] sortArray(int[] nums) {\n    quickSort(nums, 0, nums.length - 1);\n    return nums;\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int partition = partition(arr, low, high);\n        quickSort(arr, low, partition - 1);\n        quickSort(arr, partition + 1, high);\n    }\n}\n\nint partition(int arr[], int low, int high) {\n    int mid = low + (high - low) / 2, pivot = arr[mid], left = low, right = high - 1;\n\n    swap(arr, mid, high);\n    while (left <= right) {\n        if (arr[left] < pivot) left++;\n        else if (arr[right] > pivot) right--;\n        else swap(arr, left++, right--);\n    }\n    swap(arr, left, high);\n\n    return left;\n}\n\nvoid swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}","topicId":3},{"id":19,"position":2,"title":"Merge Sort","difficulty":2,"link":"https://leetcode.com/problems/sort-an-array/\nhttps://practice.geeksforgeeks.org/problems/merge-sort/1","hint":"N/A","notes":"Revision Dates: 01/08/22, 29/10/23\nLast Revision Notes: Solved without any issue.","solution":"int[] temp;\npublic int[] sortArray(int[] nums) {\n    int n = nums.length;\n    temp = new int[n];\n    mergeSort(nums, 0, n - 1);\n    return nums;\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\nvoid merge(int arr[], int l, int m, int r) {\n    int left = l, right = m + 1, idx = 0;\n\n    while (left <= m && right <= r) {\n        if (arr[left] < arr[right]) temp[idx++] = arr[left++];\n        else temp[idx++] = arr[right++];\n    }\n\n    while (left <= m) temp[idx++] = arr[left++];\n    while (right <= r) temp[idx++] = arr[right++];\n    \n    idx = 0;\n    for (int i = l; i <= r; i++) {\n        arr[i] = temp[idx++];\n    }\n}","topicId":3},{"id":20,"position":4,"title":"Merge Without Extra Space","difficulty":3,"link":"https://practice.geeksforgeeks.org/problems/merge-two-sorted-arrays-1587115620/1\nhttps://www.youtube.com/watch?v=n7uwj04E0I4","hint":"Method 1:\n* Take two pointers for left and right array say (i & j)\n* Start with i = n - 1 and j = 0.\n* Start loop while i >= 0 && j < m.\n* If arr1[i] > arr2[j] then swap else break;\n* Now you have all the elements to correct array but in unsorted order.\n* Now sort both arrays individually.\n\nMethod 2: Gap method.\n* Always take ciel value means add one before dividing by 2.\n* Take initial gap = (n + m + 1) / 2, and start loop while gap >= 1;\n* Again start the loop till (i + gap < m  + n) and compare left (i) and right (i + gap) then swap if required.\n* reduce the gap by (gap + 1) / 2.\n","notes":"Revision Dates: 01/08/22, 30/10/23\nLast Revision Notes: Learn Shell Sort for Gap Method intuition.","solution":"void merge(long arr1[], long arr2[], int n, int m) {\n    int gap = (n + m + 1) / 2;\n    while (gap >= 1) {\n        for (int left = 0; left + gap < n + m; left++) {\n            int right = left + gap;\n            if (left >= n) {\n                checkAndSwap(arr2, arr2, left - n, right - n);\n            } else if (right >= n) {\n                checkAndSwap(arr1, arr2, left, right - n);\n            } else {\n                checkAndSwap(arr1, arr1, left, right);\n            }\n        }\n\n        if (gap == 1) break;\n        else gap = (gap + 1) / 2;\n    }\n}\n\nvoid checkAndSwap(long[] arr1, long[] arr2, int i, int j) {\n    if (arr1[i] > arr2[j]) {\n        long temp = arr1[i];\n        arr1[i] = arr2[j];\n        arr2[j] = temp;\n    }\n}","topicId":3},{"id":21,"position":3,"title":"Count Inversions","difficulty":2,"link":"https://practice.geeksforgeeks.org/problems/inversion-of-array-1587115620/1","hint":"* Use merge sort algorithm\n* In merge function when arr[left] > arr[right].\n* Increase the count by (mid - left + 1).\n* Above count logic is deduced by observation that if arr[right] < arr[left] then the inversion count will be number of elements needs to be displaced from the left array in order to fit the arr[right]'s element to its correct place.","notes":"Revision Dates: 01/08/22, 31/10/23\nLast Revision Notes: Not able to think about count logic.","solution":"long count;\nlong inversionCount(long[] arr, long N) {\n    int n = (int) N;\n    count = 0;\n    mergeSort(arr, 0, n - 1);\n    return count;\n}\n\n\nlong[] temp;\nvoid mergeSort(long arr[], int l, int r) {\n    if (temp == null) temp = new long[l + r + 1];\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\nvoid merge(long arr[], int l, int m, int r) {\n    int left = l, mid = m, right = m + 1, idx = 0;\n    while (left <= m && right <= r) {\n        if (arr[left] <= arr[right]) {\n            temp[idx++] = arr[left++];\n        } else {\n            temp[idx++] = arr[right++];\n            count += mid - left + 1;\n        }\n    }\n\n    while (left <= m) {\n        temp[idx++] = arr[left++];\n    }\n\n    while (right <= r) {\n        temp[idx++] = arr[right++];\n    }\n\n    idx = 0;\n    for (int i = l; i <= r; i++) {\n        arr[i] = temp[idx++];\n    }\n}","topicId":3},{"id":22,"position":7,"title":"Search in Rotated Sorted Array","difficulty":2,"link":"https://leetcode.com/problems/search-in-rotated-sorted-array/\nhttps://practice.geeksforgeeks.org/problems/search-in-a-rotated-array4618/1","hint":"Approach 1: (First find rotation point)\n* Check if the array is rotated by nums[0] > nums[n - 1].\n* If rotated then find the rotation point \n-- Finding rotation point: By modifying Binary Search \n* if (mid - 1 >= left && nums[mid] < nums[mid - 1] || \n       mid + 1 <= right && nums[mid] > nums[mid + 1]) then return mid.\n* else if (nums[left] > nums[mid]) then right = mid - 1.\n* else then left = mid + 1.\n--\n* now if (nums[rotationPoint] == target) then rotationPoint;\n* else perform binary search in [0, rotationPoint - 1] and [rotationPoint + 1, n - 1].\n\nApproach 2: (Directly modify binary search)\n* In rotated sorted array either left or right part is always sorted.\n* Identify which part is sorted and if target lies between that part then goto that part else goto other part.\nNote: For check left is sorted (nums[left] <= nums[mid]) always use '<=' instead of '<' because when n = 2, left = mid.\n","notes":"Revision Dates: 01/08/22, 01/11/23\nLast Revision Notes: Solved without any issue.","solution":"public int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1, mid;\n\n    while (left <= right) {\n        mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[left] <= nums[mid]) {\n            // Left part is sorted\n            if (nums[left] <= target && nums[mid] > target) {\n                right = mid - 1; // Go left\n            } else {\n                left = mid + 1; // Go right\n            }\n        } else {\n            // Right part is sorted\n            if (nums[right] >= target && nums[mid] < target) {\n                left = mid + 1; // Go right\n            } else {\n                right = mid - 1; // Go left\n            }\n        }\n    }\n    return -1;\n}","topicId":3},{"id":23,"position":5,"title":"Sorting Elements of an Array by Frequency","difficulty":2,"link":"https://practice.geeksforgeeks.org/problems/sorting-elements-of-an-array-by-frequency/0","hint":"N/A","notes":"Revision Dates: 01/08/22, 02/11/23\nLast Revision Notes: Solved without any issue.","solution":"void sortArrByFreq(Integer[] arr, int n) {\n    HashMap<Integer, Integer> frequency = new HashMap<>();\n    for (int i = 0; i < n; i++) {\n        int key = arr[i];\n        int value = frequency.getOrDefault(key, 0) + 1;\n        frequency.put(key, value);\n    }\n\n    Arrays.sort(arr, (a, b) -> {\n        if (frequency.get(a) == frequency.get(b)) {\n            return a - b;\n        } else if (frequency.get(a) > frequency.get(b)) {\n            return -1;\n        } else {\n            return 1;\n        }\n    });\n}\n\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int t = in.nextInt();\n    for (int i = 0; i < t; i++) {\n        int n = in.nextInt();\n        Integer[] arr = new Integer[n];\n        for (int j = 0; j < n; j++) {\n            arr[j] = in.nextInt();\n        }\n        new GFG().sortArrByFreq(arr, n);\n        for (int j = 0; j < n; j++) {\n            System.out.print(arr[j] + \" \");\n        }\n        System.out.println();\n    }\n}","topicId":3},{"id":24,"position":8,"title":"Median of Two Sorted Arrays","difficulty":3,"link":"https://leetcode.com/problems/median-of-two-sorted-arrays/\nhttps://practice.geeksforgeeks.org/problems/sum-of-middle-elements-of-two-sorted-arrays2305/1\nhttps://www.youtube.com/watch?v=F9c7LpRZWVQ","hint":"We can apply binary search if below two conditions satisfies:\n* We need to identify the sorted part (like ans, array, logic, index).\n* We need to find the logic for moving to left/right sub-part.\n\nHere: \n* We are considering part as min(nums1, nums2) elements.\n* Suppose size of nums1 = 5 and nums2 = 7. Then mid = (5 + 7 + 1) / 2 = 6.\n* So if we take 0 element from num1 then we have to take (6 - 0 = 6) 6 element from nums2 for finding median.\n* Likewise for 3 nums1 element we can take (6 - 3 = 3) 3 nums2 element.\n* By doing this we are partitioning both the arrays in two parts and elements between the partitions will be (l,r) or l1, r1 and l2 , r2.\n* By applying logic between (l1, r1 and l2 , r2) we can easily determine if we are at the right part or we need to goto left or right.","notes":"Revision Dates: 01/08/22, 04/11/23\nLast Revision Notes: Watched YT for O(log(n)) solution.","solution":"public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    int m = nums1.length;\n    int n = nums2.length;\n    if (m > n) return findMedianSortedArrays(nums2, nums1);\n\n    long mid = (m + n + 1) / 2;\n    int start = 0, end = m;\n    while (start <= end) {\n        int partition1 = start + (end - start) / 2;\n        int partition2 = (int) (mid - partition1);\n\n        int l1 = partition1 == 0 ? Integer.MIN_VALUE : nums1[partition1 - 1];\n        int r1 = partition1 == m ? Integer.MAX_VALUE : nums1[partition1];\n        int l2 = partition2 == 0 ? Integer.MIN_VALUE : nums2[partition2 - 1];\n        int r2 = partition2 == n ? Integer.MAX_VALUE : nums2[partition2];\n\n        if (l1 > r2) {\n            end = partition1 - 1;\n        } else if (l2 > r1) {\n            start = partition1 + 1;\n        } else {\n            if ((n + m) % 2 == 0) {\n                return (Math.max(l1, l2) + Math.min(r1, r2)) / 2.0;\n            } else {\n                return Math.max(l1, l2);\n            }\n        }\n    }\n    return 0.0;\n}","topicId":3},{"id":25,"position":9,"title":"K-th element of two Arrays","difficulty":3,"link":"https://practice.geeksforgeeks.org/problems/k-th-element-of-two-sorted-array1317/1","hint":"Solve: Median of Two Sorted Arrays","notes":"Revision Dates: 01/08/22, 04/11/23\nLast Revision Notes: Solved.","solution":"public long kthElement(int nums1[], int nums2[], int m, int n, int k) {\n    if (m > n) return kthElement(nums2, nums1, n, m, k);\n    int start = 0, end = Math.min(k, m);\n    while (start <= end) {\n        int partition1 = start + (end - start) / 2;\n        int partition2 = k - partition1;\n\n        if (partition2 < 0) {\n            end = partition1 - 1;\n            continue;\n        }\n\n        if (partition2 > n) {\n            start = partition1 + 1;\n            continue;\n        }\n\n        int l1 = partition1 == 0 ? Integer.MIN_VALUE : nums1[partition1 - 1];\n        int r1 = partition1 == m ? Integer.MAX_VALUE : nums1[partition1];\n        int l2 = partition2 == 0 ? Integer.MIN_VALUE : nums2[partition2 - 1];\n        int r2 = partition2 == n ? Integer.MAX_VALUE : nums2[partition2];\n\n        if (l1 > r2) {\n            end = partition1 - 1;\n        } else if (l2 > r1) {\n            start = partition1 + 1;\n        } else {\n            return Math.max(l1, l2);\n        }\n    }\n    return 0;\n}","topicId":3},{"id":26,"position":10,"title":"Kth Largest Element in an Array","difficulty":2,"link":"https://leetcode.com/problems/kth-largest-element-in-an-array/","hint":"quickSelect(start, end):\n* partition = partition(start, end)\n* If partition == k : return arr[k]\n* else if (partition < k) : quickSelect(partition + 1, end)\n* else : quickSelect(start, partition - 1)","notes":"Revision Dates: 01/08/22, 06/11/23\nLast Revision Notes: Solved.","solution":"public int findKthLargest(int[] nums, int k) {\n    int n = nums.length, start = 0, end = n - 1;\n    k = nums.length - k;\n\n    while (start < end) {\n        int mid = start + (end - start) / 2,\n                pivot = nums[mid],\n                left = start,\n                right = end - 1;\n\n        swap(nums, mid, end);\n        while (left <= right) {\n            if (nums[left] < pivot) left++;\n            else if (nums[right] > pivot) right--;\n            else swap(nums, left++, right--);\n        }\n        swap(nums, left, end);\n\n        if (left == k) return nums[k];\n        else if (left < k) start = left + 1;\n        else end = left - 1;\n    }\n\n    return nums[k];\n}\n\nvoid swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}","topicId":3},{"id":27,"position":11,"title":"Allocate minimum number of pages","difficulty":3,"link":"https://practice.geeksforgeeks.org/problems/allocate-minimum-number-of-pages0937/1","hint":"* Perform binary search on answer space.\n* Answer space lies between maxElement and sumElements inclusive.\n* if page allocated then perform search on left part.\n* Or else perform search on the right part.","notes":"Revision Dates: 01/08/22, 06/11/23\nLast Revision Notes: Solved.","solution":"int findPages(int[] A, int N, int M) {\n    if (M > N) return -1;\n\n    int left = Integer.MIN_VALUE, right = 0;\n    for (int num : A) {\n        left = Math.max(num, left);\n        right += num;\n    }\n\n    int pages = Integer.MAX_VALUE;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        int allocatedPages = allocatePages(A, mid, M);\n\n        if (allocatedPages == -1) {\n            left = mid + 1;\n        } else {\n            pages = allocatedPages;\n            right = allocatedPages - 1;\n        }\n    }\n\n    return pages == Integer.MAX_VALUE ? -1 : pages;\n}\n\nint allocatePages(int[] arr, int pages, int students) {\n    int n = arr.length, minPages = 0, currentPages = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > pages) {\n            return -1;\n        } else if (currentPages + arr[i] <= pages) {\n            currentPages += arr[i];\n        } else {\n            minPages = Math.max(minPages, currentPages);\n            currentPages = arr[i];\n            students--;\n        }\n    }\n\n    if (currentPages <= pages) {\n        minPages = Math.max(minPages, currentPages);\n        students--;\n    }\n    return students >= 0 ? minPages : -1;\n}","topicId":3},{"id":419,"position":1,"title":"Number of Provinces - Union Find","difficulty":2,"link":"https://leetcode.com/problems/number-of-provinces/\nhttps://www.youtube.com/watch?v=8f1XPm4WOUc","hint":"Algo:\n* Create two array: parent[] and rank[] of size n.\n* Initilize parent[i] = i as each vertex will be parent of itself initially.\n* Initilize rank[] every to 1, rank represents no of connected vertex, so initially it will be 1.\n* Initilize count = n, becaues we assume all components are disconnected.\n\nFind: (returns the root of given vertex)\n* first initilize root to itself.\n* for optimization we can do path compression by parent[root] = parent[parent[root]].\n* then keep assigning root to parent[root] till root == parent[root].\n\nUnion: (combines two vertex bassed on rank if not combined already).\n* get the root of V1 and V2 using find.\n* if both roots are equal then do nothing.\n* else make parent whose rank is greater and increase the rank of parent.\n* decrease the count. (we found one more connection).\n\n\n\n\n","notes":"Revision Dates: 30/12/2023\nLast Revision Notes: Solved","solution":"public int findCircleNum(int[][] isConnected) {\n    int n = isConnected.length;\n    UnionFind unionFind = new UnionFind(n);\n    for (int V1 = 0; V1 < n - 1; V1++) {\n        for (int V2 = V1 + 1; V2 < n; V2++) {\n            if (isConnected[V1][V2] == 1) {\n                unionFind.union(V1, V2);\n            }\n        }\n    }\n    return unionFind.getComponentsCount();\n}\n\nclass UnionFind {\n    private int count;\n    private int[] parent, rank;\n\n    public UnionFind(int n) {\n        count = n;\n        parent = new int[n];\n        rank = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 1;\n        }\n    }\n\n    public int find(int V) {\n        int root = V;\n        while (root != parent[root]) {\n            // path compression by halving\n            parent[root] = parent[parent[root]];\n            root = parent[root];\n        }\n        return root;\n    }\n\n    public void union(int V1, int V2) {\n        int rootV1 = find(V1);\n        int rootV2 = find(V2);\n        if (rootV1 != rootV2) {\n            if (rank[rootV1] > rank[rootV2]) {\n                parent[rootV2] = rootV1;\n                rank[rootV1] += rank[rootV2];\n            } else {\n                parent[rootV1] = rootV2;\n                rank[rootV2] += rank[rootV1];\n            }\n            count--;\n        }\n    }\n\n    public int getComponentsCount() {\n        return count;\n    }\n}","topicId":57},{"id":420,"position":2,"title":"Alien Dictionary - Topological Sort","difficulty":3,"link":"https://practice.geeksforgeeks.org/problems/alien-dictionary/1\nhttps://www.youtube.com/watch?v=6kTZYvNNyps","hint":"DFS Topological sort:\n* Use two sets for visited and inPath.\n* First set is used to detect the processed nodes.\n* second set is ued to detect the path.\n* At last append the order.","notes":"Revision Dates: 2/1/2024\nLast Revision Notes: Not able to solve the problem.","solution":"public String findOrder(String[] dict, int N, int K) {\n    HashMap<Character, List<Character>> graph = new HashMap<>();\n    for (int i = 0; i < N - 1; i++) {\n        String word1 = dict[i];\n        String word2 = dict[i + 1];\n        for (int j = 0; j < word1.length() && j < word2.length(); j++) {\n            char c1 = word1.charAt(j), c2 = word2.charAt(j);\n            if (c1 != c2) {\n                graph.computeIfAbsent(c1, value -> new ArrayList<>()).add(c2);\n                break;\n            }\n        }\n    }\n\n    StringBuilder order = new StringBuilder();\n    HashSet<Character> visited = new HashSet<>();\n    HashSet<Character> inPath = new HashSet<>();\n    for (char j = 'a'; j < 'a' + K; j++) {\n        if (!dfs(j, graph, visited, inPath, order)) return \"\";\n    }\n    return order.reverse().toString();\n}\n\nboolean dfs(char node, HashMap<Character, List<Character>> graph,\n            HashSet<Character> visited, HashSet<Character> inPath, StringBuilder order) {\n\n    if (visited.contains(node)) return true; // already processed\n    if (inPath.contains(node)) return false; // contains loop\n\n    inPath.add(node);\n\n    if (graph.containsKey(node)) {\n        for (char dependent : graph.get(node)) {\n            if (!dfs(dependent, graph, visited, inPath, order)) return false;\n        }\n    }\n\n    inPath.remove(node);\n    visited.add(node);\n    order.append(node);\n    return true;\n}","topicId":57},{"id":422,"position":3,"title":"Network Delay Time - Dijkstra's algorithm","difficulty":2,"link":"https://leetcode.com/problems/network-delay-time/description/\nhttps://www.youtube.com/watch?v=EaphyqKU4PQ","hint":"Do BFS.\n* Take priority queue instead on normal queue.\n* Priority will be distance from K.\n* return the maxDistance 0r network delay time.","notes":"Revision Dates: 4/1/2024\nLast Revision Notes: SOlved","solution":"public int networkDelayTime(int[][] times, int n, int k) {\n    HashMap<Integer, ArrayList<int[]>> graph = new HashMap<>();\n    for (int[] time : times) {\n        graph.computeIfAbsent(time[0], v -> new ArrayList<>())\n                .add(new int[]{time[1], time[2]});\n    }\n\n    boolean[] visited = new boolean[n + 1];\n    // PriorityQueue of {node and totalDistance}\n    PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n    pq.add(new int[]{k, 0});\n\n    int count = 0, maxDistance = 0;\n    while (!pq.isEmpty()) {\n        int[] top = pq.poll();\n        if (!visited[top[0]]) {\n            count++;\n            visited[top[0]] = true;\n            maxDistance = Math.max(maxDistance, top[1]);\n            for (int[] neighbour : graph.getOrDefault(top[0], new ArrayList<>())) {\n                if (!visited[neighbour[0]]) {\n                    pq.offer(new int[]{neighbour[0], neighbour[1] + top[1]});\n                }\n            }\n        }\n    }\n\n    return count < n ? -1 : maxDistance;\n}","topicId":57},{"id":433,"position":4,"title":"Bellmon ford","difficulty":2,"link":"https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/","hint":"","notes":"Revision Dates: 15/1/2024\nLast Revision Notes:","solution":"","topicId":57},{"id":434,"position":1,"title":"Arrange Cars","difficulty":2,"link":"https://takeitoutamber.medium.com/hackerrank-coding-interview-5-assigned-parking-f74fb68f424f","hint":"We have a number of cars located on a flat surface, and we want to park them in a straight line next to each other, with no spaces in between. Each car has a certain position given by its x and y coordinates. To move a car, we need to use fuel, which is determined by how far we have to move it horizontally (along the x-axis) and vertically (along the y-axis). Our task is to find the minimum amount of fuel required to arrange all the cars in a straight line parallel to the x-axis, without any gaps between them.\n\nExample:\n\nTwo cars, with coordinates below:\n\nx = [1, 4]\n\ny = [1, 4]\n\nSolution:\n\nThe car originally located at position (1, 1) is moved to (3, 1), incurring a fuel cost of abs(3 - 1) + abs(1 - 1) = 2 + 0 = 2.\nThe car originally located at position (4, 4) is moved to (4, 1), resulting in a fuel cost of 0 + 3 = 3.\nIn total, the fuel consumed for these movements is 2 + 3 = 5.","notes":"Revision Dates: 16/1/2024\nLast Revision Notes:","solution":"","topicId":59},{"id":435,"position":2,"title":"is Palindrome possible","difficulty":3,"link":"","hint":"Given a string as an input, & a list of queries. We are given a list of queries, in each query, we have - startIndex, endIndex, number of substitutions(nos). The problem is to identify (for each query) whether the substring defined by [startIndex,endIndex] can be converted to a palindrome by applying not more than the provide number of substitutions & rearranging the substring (if required).\nFor each query, if the substring can be converted to a palindrome , append '1' to the result string else append '0' to the result string. Finally print the result string.\n\nEx- s = aabdcdwq\n\nQuery[0] = [1, 3, 1]\ns[1:3] = abd\nwe can substitue 'd' by 'a' to form 'aba' which is a palindrome , so append '1' to the result\n\nQuery[1] = [0,3, 1]\ns[0:3] = aabd\nwe can substitute 'd' by 'b' and rearrange the substring to make it \"abba\", so append '1' to the result\n\nQuery[2] = [0, 7, 1]\ns[0:7] = aabdcdwq\nNo way to make this substring palindrome in 1 substitution, so append '0' to the result\n\nprint 110\n\nConstraints:\nString consists of lowercase english letters only\nn: length of string\n1<=n <= 10^6\nnumber of queries <= 100","notes":"Revision Dates: 16/1/2024\nLast Revision Notes:","solution":"","topicId":59},{"id":436,"position":3,"title":"Secure the server","difficulty":3,"link":"https://leetcode.com/discuss/interview-question/2838608/Fivetran-HackerRank-Question-Makes-No-Sense","hint":"","notes":"Revision Dates: 16/1/2024\nLast Revision Notes:","solution":"","topicId":59},{"id":437,"position":4,"title":"Meeting","difficulty":2,"link":"https://www.codingninjas.com/studio/problems/meeting_1376415","hint":"","notes":"Revision Dates: 16/1/2024\nLast Revision Notes:","solution":"","topicId":59}]}